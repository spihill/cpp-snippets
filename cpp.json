{
	"AVLMap": {
		"prefix": "AVLMap",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"using namespace std;",
			"",
			"namespace spihill {",
			"template<class T, class U>",
			"class AVLMapIterator;",
			"",
			"template<class T, class U, class Compare = less<T>>",
			"struct AVLMap {",
			"\tstruct NODE;",
			"\tstruct NODE_LIST;",
			"\tNODE_LIST list_dummy;",
			"\tNODE node_dummy;",
			"\tfriend AVLMapIterator<T, U>;",
			"\tusing iterator = AVLMapIterator<T, U>;",
			"\tAVLMap() {",
			"\t\tnode_dummy.index = &list_dummy;",
			"\t\tlist_dummy.node = &node_dummy;",
			"\t}",
			"\tAVLMap(const AVLMap& R) {",
			"\t\tnode_dummy.index = &list_dummy;",
			"\t\tlist_dummy.node = &node_dummy;",
			"\t\tauto dfs = [&](auto f, NODE* old_node, NODE* new_node) {",
			"\t\t\tif (0) return new_node;",
			"\t\t\tif (old_node->left) {",
			"\t\t\t\tnew_node->left = f(f, old_node->left, new NODE((T&&) *(old_node->left->key), (U&&) *(old_node->left->value), new_node));",
			"\t\t\t}",
			"\t\t\tauto l = new NODE_LIST(&list_dummy, true);",
			"\t\t\tl->node = new_node;",
			"\t\t\tnew_node->index = l;",
			"\t\t\tnew_node->child_size = old_node->child_size;",
			"\t\t\tnew_node->height = old_node->height;",
			"\t\t\tif (old_node->right) {",
			"\t\t\t\tnew_node->right = f(f, old_node->right, new NODE((T&&) *(old_node->right->key), (U&&) *(old_node->right->value), new_node));",
			"\t\t\t}",
			"\t\t\treturn new_node;",
			"\t\t};",
			"\t\tif (R.node_dummy.left) node_dummy.left = dfs(dfs, R.node_dummy.left, new NODE((T&&) *(R.node_dummy.left->key), &node_dummy));",
			"\t}",
			"\tAVLMap& operator=(const AVLMap& R) {",
			"\t\tfor (NODE_LIST* p = list_dummy.fp; p != &list_dummy;) {",
			"\t\t\tp = p->fp;",
			"\t\t\tdelete p->bp;",
			"\t\t}",
			"\t\tnode_dummy.index = &list_dummy;",
			"\t\tlist_dummy.node = &node_dummy;",
			"\t\tauto dfs = [&](auto f, NODE* old_node, NODE* new_node) {",
			"\t\t\tif (0) return new_node;",
			"\t\t\tif (old_node->left) {",
			"\t\t\t\tnew_node->left = f(f, old_node->left, new NODE((T&&) *(old_node->left->key), (U&&) *(old_node->left->value), new_node));",
			"\t\t\t}",
			"\t\t\tauto l = new NODE_LIST(&list_dummy, true);",
			"\t\t\tl->node = new_node;",
			"\t\t\tnew_node->index = l;",
			"\t\t\tnew_node->child_size = old_node->child_size;",
			"\t\t\tnew_node->height = old_node->height;",
			"\t\t\tif (old_node->right) {",
			"\t\t\t\tnew_node->right = f(f, old_node->right, new NODE((T&&) *(old_node->right->key), (U&&) *(old_node->right->value), new_node));",
			"\t\t\t}",
			"\t\t\treturn new_node;",
			"\t\t};",
			"\t\tif (R.node_dummy.left) node_dummy.left = dfs(dfs, R.node_dummy.left, new NODE((T&&) *(R.node_dummy.left->key), &node_dummy));",
			"\t\treturn *this;",
			"\t}",
			"\t~AVLMap() {",
			"\t\tfor (NODE_LIST* p = list_dummy.fp; p != &list_dummy;) {",
			"\t\t\tp = p->fp;",
			"\t\t\tdelete p->bp;",
			"\t\t}",
			"\t}",
			"\tint size() {",
			"\t\tif (node_dummy.left) return node_dummy.left->child_size;",
			"\t\treturn 0;",
			"\t}",
			"\tstruct NODE_LIST {",
			"\t\tNODE_LIST* fp;",
			"\t\tNODE_LIST* bp;",
			"\t\tNODE* node;",
			"\t\tbool dummy = false;",
			"\t\tNODE_LIST() : fp(this), bp(this), node(nullptr), dummy(true) {}",
			"\t\tNODE_LIST(NODE_LIST* p, bool is_left) : node(nullptr) {",
			"\t\t\tNODE_LIST* pre = is_left ? p->bp : p;",
			"\t\t\tNODE_LIST* nex = is_left ? p : p->fp;",
			"\t\t\tbp = pre;",
			"\t\t\tfp = nex;",
			"\t\t\tpre->fp = this;",
			"\t\t\tnex->bp = this;",
			"\t\t}",
			"\t\t~NODE_LIST() {",
			"\t\t\tif (!dummy) delete node;",
			"\t\t}",
			"\t\tint get_position() {",
			"\t\t\tint result = -1;",
			"\t\t\tbool is_left = false;",
			"\t\t\tNODE* n = node;",
			"\t\t\tfor (;; n = n->par) {",
			"\t\t\t\tif (!is_left) result += n->left ? n->left->child_size + 1 : 1;",
			"\t\t\t\tif (n->par) is_left = (n->par->left == n);",
			"\t\t\t\telse break;",
			"\t\t\t}",
			"\t\t\treturn result;",
			"\t\t}",
			"\t};",
			"\tvoid remove_list(NODE_LIST* p) {",
			"\t\tp->bp->fp = p->fp;",
			"\t\tp->fp->bp = p->bp;",
			"\t\tdelete p;",
			"\t}",
			"\tvoid remove_node(NODE* n, bool is_left) {",
			"\t\tif (n->par->left == n) n->par->left = is_left ? n->left : n->right;",
			"\t\telse  n->par->right = is_left ? n->left : n->right;",
			"\t\tif (is_left) n->left->par = n->par;",
			"\t\telse n->right->par = n->par;",
			"\t\tfor (NODE* i = n->par; i != &node_dummy; i = i->par) i->child_size--;",
			"\t\tremove_list(n->index);",
			"\t}",
			"\tvoid remove_node(NODE* n) {",
			"\t\tif (n->par->left == n) n->par->left = nullptr;",
			"\t\telse  n->par->right = nullptr;",
			"\t\tfor (NODE* i = n->par; i != &node_dummy; i = i->par) i->child_size--;",
			"\t\tremove_list(n->index);",
			"\t}",
			"\tstruct NODE {",
			"\t\tT* key;",
			"\t\tU* value;",
			"\t\tNODE_LIST* index;",
			"\t\tNODE* left;",
			"\t\tNODE* right;",
			"\t\tNODE* par;",
			"\t\tint child_size;",
			"\t\tint height;",
			"\t\tNODE() : key(nullptr), value(nullptr), index(nullptr), left(nullptr), right(nullptr), par(nullptr), child_size(0), height(0) {}",
			"\t\tNODE(T&& d, NODE* par_) : index(nullptr), left(nullptr) , right(nullptr), par(par_), child_size(1), height(1) {key = new T(d); value = new U;}",
			"\t\tNODE(T&& d, U&& u, NODE* par_) : index(nullptr), left(nullptr) , right(nullptr), par(par_), child_size(1), height(1) {key = new T(d); value = new U(u);}",
			"\t\t~NODE() {delete key; delete value;}",
			"\t\tvoid RotateR() {",
			"\t\t\tNODE* P = this;",
			"\t\t\tNODE* R = this->par;",
			"\t\t\tNODE* l = this->left;",
			"\t\t\tNODE* B = l->right;",
			"\t\t\tif (R->left == P) R->left = l;",
			"\t\t\telse R->right = l;",
			"\t\t\tl->par = R;",
			"\t\t\tif (B) B->par = P;",
			"\t\t\tP->left = B;",
			"\t\t\tl->right = P;",
			"\t\t\tP->par = l;",
			"\t\t\tint B_size = B ? B->child_size : 0;",
			"\t\t\tP->child_size += B_size - l->child_size;",
			"\t\t\tl->child_size += P->child_size - B_size;",
			"\t\t\tP->update_height();",
			"\t\t\tl->update_height();",
			"\t\t}",
			"\t\tvoid RotateL() {",
			"\t\t\tNODE* P = this;",
			"\t\t\tNODE* R = this->par;",
			"\t\t\tNODE* r = this->right;",
			"\t\t\tNODE* B = r->left;",
			"\t\t\tif (R->left == P) R->left = r;",
			"\t\t\telse R->right = r;",
			"\t\t\tr->par = R;",
			"\t\t\tif (B) B->par = P;",
			"\t\t\tP->right = B;",
			"\t\t\tr->left = P;",
			"\t\t\tP->par = r;",
			"\t\t\tint B_size = B ? B->child_size : 0;",
			"\t\t\tP->child_size += B_size - r->child_size;",
			"\t\t\tr->child_size += P->child_size - B_size;",
			"\t\t\tP->update_height();",
			"\t\t\tr->update_height();",
			"\t\t}",
			"\t\tvoid RotateRL() {",
			"\t\t\tright->RotateR();",
			"\t\t\tRotateL();",
			"\t\t}",
			"\t\tvoid RotateLR() {",
			"\t\t\tleft->RotateL();",
			"\t\t\tRotateR();",
			"\t\t}",
			"\t\tint bias() {",
			"\t\t\tint L = left  ? left->height  : 0;",
			"\t\t\tint R = right ? right->height : 0;",
			"\t\t\treturn L - R;",
			"\t\t}",
			"\t\tvoid update_height() {",
			"\t\t\tint L = left  ? left->height  : 0;",
			"\t\t\tint R = right ? right->height : 0;",
			"\t\t\theight = max(L, R) + 1;",
			"\t\t}",
			"\t};",
			"\tvoid balancing_insert(NODE* parent) {",
			"\t\tfor (;!(parent->index->dummy); parent = parent->par) {",
			"\t\t\tparent->update_height();",
			"\t\t\tif (parent->bias() == 0) return;",
			"\t\t\tif (abs(parent->bias()) != 1) break;",
			"\t\t}",
			"\t\tif (parent != &node_dummy) balancing_rotate(parent);",
			"\t}",
			"\tvoid balancing_erase(NODE* parent) {",
			"\t\tfor (;; parent = parent->par->par) {",
			"\t\t\tfor (;!(parent->index->dummy); parent = parent->par) {",
			"\t\t\t\tparent->update_height();",
			"\t\t\t\tif (abs(parent->bias()) == 1) return;",
			"\t\t\t\tif (parent->bias() != 0) break;",
			"\t\t\t}",
			"\t\t\tif (parent == &node_dummy) return;",
			"\t\t\tbalancing_rotate(parent);",
			"\t\t}",
			"\t}",
			"\tvoid balancing_rotate(NODE* parent) {",
			"\t\tif (parent->bias() == 2) {",
			"\t\t\tif (parent->left->bias() == -1) parent->RotateLR();",
			"\t\t\telse parent->RotateR();",
			"\t\t} else {",
			"\t\t\tif (parent->right->bias() == 1) parent->RotateRL();",
			"\t\t\telse parent->RotateL();",
			"\t\t}",
			"\t}",
			"\titerator erase(T&& k) {",
			"\t\tNODE* now = node_dummy.left;",
			"\t\twhile (now) {",
			"\t\t\tif (Compare()(k, *(now->key))) now = now->left;",
			"\t\t\telse if (Compare()(*(now->key), k)) now = now->right;",
			"\t\t\telse break;",
			"\t\t}",
			"\t\tif (now == nullptr) return iterator(&list_dummy);",
			"\t\tNODE* target;",
			"\t\tif (now->left) target = now->index->bp->node;",
			"\t\telse target = now;",
			"\t\tassert(target->child_size <= 2);",
			"\t\tNODE_LIST* res = now->index->fp;",
			"\t\tswap(now->key, target->key);",
			"\t\tnow = target->par;",
			"\t\tbool is_left = (now->left == target);",
			"\t\tif (target->left) remove_node(target, true);",
			"\t\telse if (target->right) remove_node(target, false);",
			"\t\telse remove_node(target);",
			"\t\tbalancing_erase(now);",
			"\t\treturn iterator(res);",
			"\t}",
			"\titerator erase(const T& k) {",
			"\t\treturn erase((T&&) k);",
			"\t}",
			"\titerator insert(T&& k) {",
			"\t\tNODE* parent = &node_dummy;",
			"\t\tNODE* now = parent->left;",
			"\t\tbool is_left = true;",
			"\t\twhile (now) {",
			"\t\t\tparent = now;",
			"\t\t\tnow->child_size++;",
			"\t\t\tif (is_left = Compare()(k, *(now->key))) now = now->left;",
			"\t\t\telse if (is_left = Compare()(*(now->key), k)) now = now->right;",
			"\t\t\telse return iterator(now->index);",
			"\t\t}",
			"\t\tNODE* child = new NODE((T&&) k, parent);",
			"\t\tif (is_left) parent->left = child;",
			"\t\telse parent->right = child;",
			"\t\tchild->index = new NODE_LIST(parent->index, is_left);",
			"\t\tchild->index->node = child;",
			"\t\tbalancing_insert(parent);",
			"\t\treturn iterator(child->index);",
			"\t}",
			"\titerator insert(const T& k) {",
			"\t\treturn insert((T&&) k);",
			"\t}",
			"\tint count(T&& v) {",
			"\t\tenum STATUS {LEFT, RIGHT, NEUTRAL};",
			"\t\tint sum = 0;",
			"\t\tqueue<pair<STATUS, NODE*>> q;",
			"\t\tq.emplace(NEUTRAL, node_dummy.left);",
			"\t\twhile (!q.empty()) {",
			"\t\t\tpair<STATUS, NODE*> t = q.front();",
			"\t\t\tq.pop();",
			"\t\t\tint status = t.first;",
			"\t\t\tNODE* n = t.second;",
			"\t\t\tif (n == nullptr) continue;",
			"\t\t\tif (status == NEUTRAL) {",
			"\t\t\t\tif (Compare()(v, *(n->key))) q.emplace(NEUTRAL, n->left);",
			"\t\t\t\telse if (Compare()(*(n->key), v)) q.emplace(NEUTRAL, n->right);",
			"\t\t\t\telse {",
			"\t\t\t\t\tsum++;",
			"\t\t\t\t\tq.emplace(LEFT, n->left);",
			"\t\t\t\t\tq.emplace(RIGHT, n->right);",
			"\t\t\t\t}",
			"\t\t\t} else if (status == LEFT) {",
			"\t\t\t\tif (Compare()(*(n->key), v)) q.emplace(LEFT, n->right);",
			"\t\t\t\telse {",
			"\t\t\t\t\tsum += (n->right ? n->right->child_size : 0) + 1;",
			"\t\t\t\t\tq.emplace(LEFT, n->left);",
			"\t\t\t\t}",
			"\t\t\t} else /* if (status == RIGHT) */{",
			"\t\t\t\tif (Compare()(v, *(n->key))) q.emplace(RIGHT, n->left);",
			"\t\t\t\telse {",
			"\t\t\t\t\tsum += (n->left ? n->left->child_size : 0) + 1;",
			"\t\t\t\t\tq.emplace(RIGHT, n->right);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn sum;",
			"\t}",
			"\tint count(const T& v) {",
			"\t\treturn count((T&&) v);",
			"\t}",
			"\tbool is_balanced() {",
			"\t\tauto dfs = [&](auto f, NODE* n, int& height, int& c_size) {",
			"\t\t\tif (0) return false;",
			"\t\t\tif (n == nullptr) {",
			"\t\t\t\theight = 0;",
			"\t\t\t\tc_size = 0;",
			"\t\t\t\treturn true;",
			"\t\t\t}",
			"\t\t\tint L = 0, R = 0;",
			"\t\t\tc_size = 1;",
			"\t\t\tint t;",
			"\t\t\tif (!f(f, n->left, L, t)) return false;",
			"\t\t\tc_size += t;",
			"\t\t\tif (!f(f, n->right, R, t)) return false;",
			"\t\t\tc_size += t;",
			"\t\t\theight = max(L, R) + 1;",
			"\t\t\tif (n->height != height) {",
			"\t\t\t\tcerr << \"hight value is odd.\" << endl;",
			"\t\t\t\treturn false;",
			"\t\t\t}",
			"\t\t\tif (n->bias() < -2 || n->bias() > 2) {",
			"\t\t\t\tcerr << \"bias value is odd.\" << endl;",
			"\t\t\t\tcerr << \"bias : \" << n->bias() << endl;",
			"\t\t\t\treturn false;",
			"\t\t\t}",
			"\t\t\tif (c_size != n->child_size) {",
			"\t\t\t\tcerr << \"child_size is wrong\" << endl;",
			"\t\t\t\tcerr << \"size : \" << n->child_size << endl;",
			"\t\t\t\tcerr << \"real : \" << c_size << endl;",
			"\t\t\t\treturn false;",
			"\t\t\t}",
			"\t\t\theight = std::max(L, R) + 1;",
			"\t\t\treturn true;",
			"\t\t};",
			"\t\tint t, u;",
			"\t\treturn dfs(dfs, node_dummy.left, t, u);",
			"\t}",
			"\titerator begin() {",
			"\t\treturn iterator(list_dummy.fp);",
			"\t}",
			"\titerator end() {",
			"\t\treturn iterator(&list_dummy);",
			"\t}",
			"\titerator lower_bound(T&& v) {",
			"\t\tNODE* now = node_dummy.left;",
			"\t\tNODE* ans = nullptr;",
			"\t\twhile (now != nullptr) {",
			"\t\t\tif (Compare()(*(now->key), v)) {",
			"\t\t\t\tnow = now->right;",
			"\t\t\t}",
			"\t\t\telse {",
			"\t\t\t\tans = now;",
			"\t\t\t\tnow = now->left;",
			"\t\t\t}",
			"\t\t}",
			"\t\tif (ans) return iterator(ans->index);",
			"\t\treturn iterator(&list_dummy);",
			"\t}",
			"\titerator lower_bound(const T& v) {",
			"\t\treturn lower_bound((T&&) v);",
			"\t}",
			"\titerator upper_bound(T&& v) {",
			"\t\tNODE* now = node_dummy.left;",
			"\t\tNODE* ans = nullptr;",
			"\t\twhile (now != nullptr) {",
			"\t\t\tif (Compare()(v, *(now->key))) {",
			"\t\t\t\tans = now;",
			"\t\t\t\tnow = now->left;",
			"\t\t\t}",
			"\t\t\telse {",
			"\t\t\t\tnow = now->right;",
			"\t\t\t}",
			"\t\t}",
			"\t\tif (ans) return iterator(ans->index);",
			"\t\treturn iterator(&list_dummy);",
			"\t}",
			"\titerator upper_bound(const T& v) {",
			"\t\treturn upper_bound((T&&) v);",
			"\t}",
			"//\tconst T& get_kth_element(int k) {",
			"//\t\tif (k < 0 || size() <= k) throw out_of_range(\"Error at AVLMap::get_kth_element(int)\");",
			"//\t\tint pos = 0;",
			"//\t\tNODE* now = node_dummy.left;",
			"//\t\twhile (true) {",
			"//\t\t\tint L = now->left ? now->left->child_size : 0;",
			"//\t\t\tif (Compare()(pos + L, k)) pos += L + 1, now = now->right;",
			"//\t\t\telse if (Compare()(k, L + pos)) now = now->left;",
			"//\t\t\telse break;",
			"//\t\t}",
			"//\t\treturn *(now->key);",
			"//\t}",
			"\tU& operator[](T&& k) {",
			"\t\treturn *(insert((T&&) k).list_ptr->node->value);",
			"\t}",
			"\tU& operator[](const T& k) {",
			"\t\treturn *(insert((T&&) k).list_ptr->node->value);",
			"\t}",
			"};",
			"template<class T, class U>",
			"class AVLMapIterator {",
			"\tfriend AVLMap<T, U>;",
			"\tusing NODE_LIST = typename AVLMap<T, U>::NODE_LIST;",
			"\tNODE_LIST* list_ptr;",
			"\tAVLMapIterator(NODE_LIST* n) : list_ptr(n) {}",
			"public:",
			"\tAVLMapIterator(const AVLMapIterator& R) : list_ptr(R.list_ptr) {}",
			"\tAVLMapIterator& operator++() {",
			"\t\tif (list_ptr->dummy) throw out_of_range(\"Error at AVLMapIterator& operator++()\");",
			"\t\tlist_ptr = list_ptr->fp;",
			"\t\treturn *this;",
			"\t}",
			"\tAVLMapIterator operator++(int unused) {",
			"\t\tif (list_ptr->dummy) throw out_of_range(\"Error at AVLMapIterator operator++(int)\");",
			"\t\tAVLMapIterator result = *this;",
			"\t\tlist_ptr = list_ptr->fp;",
			"\t\treturn result;",
			"\t}",
			"\tAVLMapIterator& operator--() {",
			"\t\tif (list_ptr->bp->dummy) throw out_of_range(\"Error at AVLMapIterator& operator--()\");",
			"\t\tlist_ptr = list_ptr->bp;",
			"\t\treturn *this;",
			"\t}",
			"\tAVLMapIterator operator--(int unused) {",
			"\t\tif (list_ptr->bp->dummy) throw out_of_range(\"Error at AVLMapIterator operator--(int)\");",
			"\t\tAVLMapIterator result = *this;",
			"\t\tlist_ptr = list_ptr->bp;",
			"\t\treturn result;",
			"\t}",
			"\tint operator-(const AVLMapIterator& R) {",
			"\t\treturn list_ptr->get_position() - R.list_ptr->get_position();",
			"\t}",
			"\tconst pair<T, U> operator*() const {",
			"\t\tassert(list_ptr->node->key);",
			"\t\treturn make_pair(*(list_ptr->node->key), *(list_ptr->node->value));",
			"\t}",
			"\tbool operator==(const AVLMapIterator& R) {",
			"\t\treturn this->list_ptr == R.list_ptr;",
			"\t}",
			"\tbool operator!=(const AVLMapIterator& R) {",
			"\t\treturn !(*this == R);",
			"\t}",
			"};",
			"} // namespace",
			"",
			"using namespace spihill;",
			"",
			"/*",
			"",
			"void check_insert(const int);",
			"void check_erase(const int);",
			"bool check(AVLMap<int, int>& R, multiset<int>& S);",
			"*/",
			"int main()",
			"{",
			"\tcout << \"INSERT TEST\" << endl;",
			"//\tcheck_insert(100000);",
			"\tcout << \"TEST PASSED\" << endl;",
			"\tcout << \"ERASE TEST\" << endl;",
			"\tAVLMap<int, int> A;",
			"\tfor (int i = 9; i >= 0; i--) {",
			"\t\tA[i * i] = i;",
			"\t}",
			"\tfor (auto x : A) {",
			"\t\tcout << x.first << \" \" << x.second << endl;",
			"\t}",
			"//\tcheck_erase(100000);",
			"\tcout << \"TEST PASSED\" << endl;",
			"}",
			"",
			"/*",
			"",
			"void check_insert(const int MAX)",
			"{",
			"\tAVLMap<int, int> R_random_big;",
			"\tAVLMap<int, int> R_random_small;",
			"\tAVLMap<int, int> R_increase;",
			"\tAVLMap<int, int> R_decrease;",
			"",
			"\tmultiset<int> S_random_big;",
			"\tmultiset<int> S_random_small;",
			"\tmultiset<int> S_increase;",
			"\tmultiset<int> S_decrease;",
			"",
			"\tstd::random_device seed_gen;",
			"\tstd::mt19937 engine(seed_gen());",
			"",
			"\tstd::uniform_real_distribution<> dist1(-1.0, 1.0);",
			"",
			"\tfor (int i = -MAX; i < MAX; i++) {",
			"\t\tint big = 1000000000 * dist1(engine);",
			"\t\tint small = 100 * dist1(engine);",
			"\t\tR_random_big.insert(big);",
			"\t\tR_random_small.insert(small);",
			"\t\tR_increase.insert(i);",
			"\t\tR_decrease.insert(-i);",
			"\t\tS_random_big.insert(big);",
			"\t\tS_random_small.insert(small);",
			"\t\tS_increase.insert(i);",
			"\t\tS_decrease.insert(-i);",
			"\t}",
			"",
			"\tauto R_copy(R_random_big);",
			"\tauto S_copy = S_random_big;",
			"\tAVLMap<int, int> R_assign;",
			"\tR_assign = R_random_big;",
			"\tfor (int i = -MAX; i < MAX; i++) {",
			"\t\tint big = 1000000000 * dist1(engine);",
			"\t\tR_copy.insert(big);",
			"\t\tR_assign.insert(big);",
			"\t\tS_copy.insert(big);",
			"\t}",
			"\tassert(check(R_increase, S_increase));",
			"\tassert(check(R_decrease, S_decrease));",
			"\tassert(check(R_random_big, S_random_big));",
			"\tassert(check(R_random_small, S_random_small));",
			"\tassert(check(R_copy, S_copy));",
			"\tassert(check(R_assign, S_copy));",
			"\tassert(R_increase.is_balanced());",
			"\tassert(R_decrease.is_balanced());",
			"\tassert(R_random_big.is_balanced());",
			"\tassert(R_random_small.is_balanced());",
			"\tassert(R_copy.is_balanced());",
			"\tassert(R_assign.is_balanced());",
			"\treturn;",
			"}",
			"",
			"",
			"void check_erase(const int MAX)",
			"{",
			"\tAVLMap<int, int> R_random_small;",
			"\tAVLMap<int, int> R_increase;",
			"\tAVLMap<int, int> R_decrease;",
			"\tAVLMap<int, int> R_nothing;",
			"",
			"\tmultiset<int> S_random_small;",
			"\tmultiset<int> S_increase;",
			"\tmultiset<int> S_decrease;",
			"\tmultiset<int> S_nothing;",
			"",
			"\tstd::random_device seed_gen;",
			"\tstd::mt19937 engine(seed_gen());",
			"",
			"\tstd::uniform_real_distribution<> dist1(-1.0, 1.0);",
			"",
			"\tfor (int i = -MAX; i < MAX; i++) {",
			"\t\tint big = 1000000000 * dist1(engine);",
			"\t\tint small = 100 * dist1(engine);",
			"\t\tR_random_small.insert(small);",
			"\t\tR_increase.insert(i);",
			"\t\tR_decrease.insert(i);",
			"\t\tR_nothing.insert(big);",
			"\t\tS_random_small.insert(small);",
			"\t\tS_increase.insert(i);",
			"\t\tS_decrease.insert(i);",
			"\t}",
			"\tfor (int i = 0; i < MAX; i++) {",
			"\t\tR_increase.erase(-i - 1);",
			"\t\tR_decrease.erase(i);",
			"\t\tS_increase.erase(-i - 1);",
			"\t\tS_decrease.erase(i);",
			"\t}",
			"",
			"\tfor (int i = -100; i <= 100; i++) {",
			"\t\tassert(R_random_small.count(i) == (int) S_random_small.count(i));",
			"\t\tassert((int) S_random_small.count(i) == R_random_small.upper_bound(i) - R_random_small.lower_bound(i));",
			"\t}",
			"",
			"\tfor (int i = 0; i < 10; i++) {",
			"\t\tint small = 100 * dist1(engine);",
			"\t\twhile (R_random_small.erase(small) != R_random_small.end());",
			"\t\tS_random_small.erase(small);",
			"\t}",
			"",
			"\tfor (int i = -100; i <= 100; i++) {",
			"\t\tassert(R_random_small.count(i) == (int) S_random_small.count(i));",
			"\t\tassert((int) S_random_small.count(i) == R_random_small.upper_bound(i) - R_random_small.lower_bound(i));",
			"\t}",
			"",
			"",
			"\twhile (R_nothing.erase(*(R_nothing.begin())) != R_nothing.end());",
			"",
			"\tassert(check(R_increase, S_increase));",
			"\tassert(check(R_decrease, S_decrease));",
			"\tassert(check(R_random_small, S_random_small));",
			"\tassert(check(R_nothing, S_nothing));",
			"\tassert(R_increase.is_balanced());",
			"\tassert(R_random_small.is_balanced());",
			"\tassert(R_decrease.is_balanced());",
			"\treturn;",
			"}",
			"",
			"bool check(AVLMap<int, int>& A, multiset<int>& S)",
			"{",
			"\tauto S_itr = S.begin();",
			"\tauto A_itr = A.begin();",
			"\tfor (;A_itr != A.end(); S_itr++, A_itr++) {",
			"\t\tif (*S_itr != *A_itr) return false;",
			"\t}",
			"\treturn S_itr == S.end();",
			"}",
			"*/"
		]
	},
	"AVLSet": {
		"prefix": "AVLSet",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"using namespace std;",
			"",
			"namespace spihill {",
			"template<class T>",
			"class AVLSetIterator;",
			"",
			"template<class T, class Compare = less<T>>",
			"struct AVLSet {",
			"\tstruct NODE;",
			"\tstruct NODE_LIST;",
			"\tNODE_LIST list_dummy;",
			"\tNODE node_dummy;",
			"\tfriend AVLSetIterator<T>;",
			"\tusing iterator = AVLSetIterator<T>;",
			"\tAVLSet() {",
			"\t\tnode_dummy.index = &list_dummy;",
			"\t\tlist_dummy.node = &node_dummy;",
			"\t}",
			"\tAVLSet(const AVLSet& R) {",
			"\t\tnode_dummy.index = &list_dummy;",
			"\t\tlist_dummy.node = &node_dummy;",
			"\t\tauto dfs = [&](auto f, NODE* old_node, NODE* new_node) {",
			"\t\t\tif (0) return new_node;",
			"\t\t\tif (old_node->left) {",
			"\t\t\t\tnew_node->left = f(f, old_node->left, new NODE((T&&) *(old_node->left->key), new_node));",
			"\t\t\t}",
			"\t\t\tauto l = new NODE_LIST(&list_dummy, true);",
			"\t\t\tl->node = new_node;",
			"\t\t\tnew_node->index = l;",
			"\t\t\tnew_node->child_size = old_node->child_size;",
			"\t\t\tnew_node->height = old_node->height;",
			"\t\t\tif (old_node->right) {",
			"\t\t\t\tnew_node->right = f(f, old_node->right, new NODE((T&&) *(old_node->right->key), new_node));",
			"\t\t\t}",
			"\t\t\treturn new_node;",
			"\t\t};",
			"\t\tif (R.node_dummy.left) node_dummy.left = dfs(dfs, R.node_dummy.left, new NODE((T&&) *(R.node_dummy.left->key), &node_dummy));",
			"\t}",
			"\tAVLSet& operator=(const AVLSet& R) {",
			"\t\tfor (NODE_LIST* p = list_dummy.fp; p != &list_dummy;) {",
			"\t\t\tp = p->fp;",
			"\t\t\tdelete p->bp;",
			"\t\t}",
			"\t\tnode_dummy.index = &list_dummy;",
			"\t\tlist_dummy.node = &node_dummy;",
			"\t\tauto dfs = [&](auto f, NODE* old_node, NODE* new_node) {",
			"\t\t\tif (0) return new_node;",
			"\t\t\tif (old_node->left) {",
			"\t\t\t\tnew_node->left = f(f, old_node->left, new NODE((T&&) *(old_node->left->key), new_node));",
			"\t\t\t}",
			"\t\t\tauto l = new NODE_LIST(&list_dummy, true);",
			"\t\t\tl->node = new_node;",
			"\t\t\tnew_node->index = l;",
			"\t\t\tnew_node->child_size = old_node->child_size;",
			"\t\t\tnew_node->height = old_node->height;",
			"\t\t\tif (old_node->right) {",
			"\t\t\t\tnew_node->right = f(f, old_node->right, new NODE((T&&) *(old_node->right->key), new_node));",
			"\t\t\t}",
			"\t\t\treturn new_node;",
			"\t\t};",
			"\t\tif (R.node_dummy.left) node_dummy.left = dfs(dfs, R.node_dummy.left, new NODE((T&&) *(R.node_dummy.left->key), &node_dummy));",
			"\t\treturn *this;",
			"\t}",
			"\t~AVLSet() {",
			"\t\tfor (NODE_LIST* p = list_dummy.fp; p != &list_dummy;) {",
			"\t\t\tp = p->fp;",
			"\t\t\tdelete p->bp;",
			"\t\t}",
			"\t}",
			"\tint size() {",
			"\t\tif (node_dummy.left) return node_dummy.left->child_size;",
			"\t\treturn 0;",
			"\t}",
			"\tstruct NODE_LIST {",
			"\t\tNODE_LIST* fp;",
			"\t\tNODE_LIST* bp;",
			"\t\tNODE* node;",
			"\t\tbool dummy = false;",
			"\t\tNODE_LIST() : fp(this), bp(this), node(nullptr), dummy(true) {}",
			"\t\tNODE_LIST(NODE_LIST* p, bool is_left) : node(nullptr) {",
			"\t\t\tNODE_LIST* pre = is_left ? p->bp : p;",
			"\t\t\tNODE_LIST* nex = is_left ? p : p->fp;",
			"\t\t\tbp = pre;",
			"\t\t\tfp = nex;",
			"\t\t\tpre->fp = this;",
			"\t\t\tnex->bp = this;",
			"\t\t}",
			"\t\t~NODE_LIST() {",
			"\t\t\tif (!dummy) delete node;",
			"\t\t}",
			"\t\tint get_position() {",
			"\t\t\tint result = -1;",
			"\t\t\tbool is_left = false;",
			"\t\t\tNODE* n = node;",
			"\t\t\tfor (;; n = n->par) {",
			"\t\t\t\tif (!is_left) result += n->left ? n->left->child_size + 1 : 1;",
			"\t\t\t\tif (n->par) is_left = (n->par->left == n);",
			"\t\t\t\telse break;",
			"\t\t\t}",
			"\t\t\treturn result;",
			"\t\t}",
			"\t};",
			"\tvoid remove_list(NODE_LIST* p) {",
			"\t\tp->bp->fp = p->fp;",
			"\t\tp->fp->bp = p->bp;",
			"\t\tdelete p;",
			"\t}",
			"\tvoid remove_node(NODE* n, bool is_left) {",
			"\t\tif (n->par->left == n) n->par->left = is_left ? n->left : n->right;",
			"\t\telse  n->par->right = is_left ? n->left : n->right;",
			"\t\tif (is_left) n->left->par = n->par;",
			"\t\telse n->right->par = n->par;",
			"\t\tfor (NODE* i = n->par; i != &node_dummy; i = i->par) i->child_size--;",
			"\t\tremove_list(n->index);",
			"\t}",
			"\tvoid remove_node(NODE* n) {",
			"\t\tif (n->par->left == n) n->par->left = nullptr;",
			"\t\telse  n->par->right = nullptr;",
			"\t\tfor (NODE* i = n->par; i != &node_dummy; i = i->par) i->child_size--;",
			"\t\tremove_list(n->index);",
			"\t}",
			"\tstruct NODE {",
			"\t\tT* key;",
			"\t\tNODE_LIST* index;",
			"\t\tNODE* left;",
			"\t\tNODE* right;",
			"\t\tNODE* par;",
			"\t\tint child_size;",
			"\t\tint height;",
			"\t\tNODE() : key(nullptr), index(nullptr), left(nullptr), right(nullptr), par(nullptr), child_size(0), height(0) {}",
			"\t\tNODE(T&& d, NODE* par_) : index(nullptr), left(nullptr) , right(nullptr), par(par_), child_size(1), height(1) {key = new T(d);}",
			"\t\t~NODE() {delete key;}",
			"\t\tvoid RotateR() {",
			"\t\t\tNODE* P = this;",
			"\t\t\tNODE* R = this->par;",
			"\t\t\tNODE* l = this->left;",
			"\t\t\tNODE* B = l->right;",
			"\t\t\tif (R->left == P) R->left = l;",
			"\t\t\telse R->right = l;",
			"\t\t\tl->par = R;",
			"\t\t\tif (B) B->par = P;",
			"\t\t\tP->left = B;",
			"\t\t\tl->right = P;",
			"\t\t\tP->par = l;",
			"\t\t\tint B_size = B ? B->child_size : 0;",
			"\t\t\tP->child_size += B_size - l->child_size;",
			"\t\t\tl->child_size += P->child_size - B_size;",
			"\t\t\tP->update_height();",
			"\t\t\tl->update_height();",
			"\t\t}",
			"\t\tvoid RotateL() {",
			"\t\t\tNODE* P = this;",
			"\t\t\tNODE* R = this->par;",
			"\t\t\tNODE* r = this->right;",
			"\t\t\tNODE* B = r->left;",
			"\t\t\tif (R->left == P) R->left = r;",
			"\t\t\telse R->right = r;",
			"\t\t\tr->par = R;",
			"\t\t\tif (B) B->par = P;",
			"\t\t\tP->right = B;",
			"\t\t\tr->left = P;",
			"\t\t\tP->par = r;",
			"\t\t\tint B_size = B ? B->child_size : 0;",
			"\t\t\tP->child_size += B_size - r->child_size;",
			"\t\t\tr->child_size += P->child_size - B_size;",
			"\t\t\tP->update_height();",
			"\t\t\tr->update_height();",
			"\t\t}",
			"\t\tvoid RotateRL() {",
			"\t\t\tright->RotateR();",
			"\t\t\tRotateL();",
			"\t\t}",
			"\t\tvoid RotateLR() {",
			"\t\t\tleft->RotateL();",
			"\t\t\tRotateR();",
			"\t\t}",
			"\t\tint bias() {",
			"\t\t\tint L = left  ? left->height  : 0;",
			"\t\t\tint R = right ? right->height : 0;",
			"\t\t\treturn L - R;",
			"\t\t}",
			"\t\tvoid update_height() {",
			"\t\t\tint L = left  ? left->height  : 0;",
			"\t\t\tint R = right ? right->height : 0;",
			"\t\t\theight = max(L, R) + 1;",
			"\t\t}",
			"\t};",
			"\tvoid balancing_insert(NODE* parent) {",
			"\t\tfor (;!(parent->index->dummy); parent = parent->par) {",
			"\t\t\tparent->update_height();",
			"\t\t\tif (parent->bias() == 0) return;",
			"\t\t\tif (abs(parent->bias()) != 1) break;",
			"\t\t}",
			"\t\tif (parent != &node_dummy) balancing_rotate(parent);",
			"\t}",
			"\tvoid balancing_erase(NODE* parent) {",
			"\t\tfor (;; parent = parent->par->par) {",
			"\t\t\tfor (;!(parent->index->dummy); parent = parent->par) {",
			"\t\t\t\tparent->update_height();",
			"\t\t\t\tif (abs(parent->bias()) == 1) return;",
			"\t\t\t\tif (parent->bias() != 0) break;",
			"\t\t\t}",
			"\t\t\tif (parent == &node_dummy) return;",
			"\t\t\tbalancing_rotate(parent);",
			"\t\t}",
			"\t}",
			"\tvoid balancing_rotate(NODE* parent) {",
			"\t\tif (parent->bias() == 2) {",
			"\t\t\tif (parent->left->bias() == -1) parent->RotateLR();",
			"\t\t\telse parent->RotateR();",
			"\t\t} else {",
			"\t\t\tif (parent->right->bias() == 1) parent->RotateRL();",
			"\t\t\telse parent->RotateL();",
			"\t\t}",
			"\t}",
			"\titerator erase(T&& k) {",
			"\t\tNODE* now = node_dummy.left;",
			"\t\twhile (now) {",
			"\t\t\tif (Compare()(k, *(now->key))) now = now->left;",
			"\t\t\telse if (Compare()(*(now->key), k)) now = now->right;",
			"\t\t\telse break;",
			"\t\t}",
			"\t\tif (now == nullptr) return iterator(&list_dummy);",
			"\t\tNODE* target;",
			"\t\tif (now->left) target = now->index->bp->node;",
			"\t\telse target = now;",
			"\t\tassert(target->child_size <= 2);",
			"\t\tNODE_LIST* res = now->index->fp;",
			"\t\tswap(now->key, target->key);",
			"\t\tnow = target->par;",
			"\t\tbool is_left = (now->left == target);",
			"\t\tif (target->left) remove_node(target, true);",
			"\t\telse if (target->right) remove_node(target, false);",
			"\t\telse remove_node(target);",
			"\t\tbalancing_erase(now);",
			"\t\treturn iterator(res);",
			"\t}",
			"\titerator erase(const T& k) {",
			"\t\treturn erase((T&&) k);",
			"\t}",
			"\titerator insert(T&& k) {",
			"\t\tNODE* parent = &node_dummy;",
			"\t\tNODE* now = parent->left;",
			"\t\tbool is_left = true;",
			"\t\twhile (now) {",
			"\t\t\tparent = now;",
			"\t\t\tnow->child_size++;",
			"\t\t\tif (is_left = Compare()(k, *(now->key))) now = now->left;",
			"\t\t\telse now = now->right;",
			"\t\t}",
			"\t\tNODE* child = new NODE((T&&) k, parent);",
			"\t\tif (is_left) parent->left = child;",
			"\t\telse parent->right = child;",
			"\t\tchild->index = new NODE_LIST(parent->index, is_left);",
			"\t\tchild->index->node = child;",
			"\t\tbalancing_insert(parent);",
			"\t\treturn iterator(child->index);",
			"\t}",
			"\titerator insert(const T& k) {",
			"\t\treturn insert((T&&) k);",
			"\t}",
			"\tint count(T&& v) {",
			"\t\tenum STATUS {LEFT, RIGHT, NEUTRAL};",
			"\t\tint sum = 0;",
			"\t\tqueue<pair<STATUS, NODE*>> q;",
			"\t\tq.emplace(NEUTRAL, node_dummy.left);",
			"\t\twhile (!q.empty()) {",
			"\t\t\tpair<STATUS, NODE*> t = q.front();",
			"\t\t\tq.pop();",
			"\t\t\tint status = t.first;",
			"\t\t\tNODE* n = t.second;",
			"\t\t\tif (n == nullptr) continue;",
			"\t\t\tif (status == NEUTRAL) {",
			"\t\t\t\tif (Compare()(v, *(n->key))) q.emplace(NEUTRAL, n->left);",
			"\t\t\t\telse if (Compare()(*(n->key), v)) q.emplace(NEUTRAL, n->right);",
			"\t\t\t\telse {",
			"\t\t\t\t\tsum++;",
			"\t\t\t\t\tq.emplace(LEFT, n->left);",
			"\t\t\t\t\tq.emplace(RIGHT, n->right);",
			"\t\t\t\t}",
			"\t\t\t} else if (status == LEFT) {",
			"\t\t\t\tif (Compare()(*(n->key), v)) q.emplace(LEFT, n->right);",
			"\t\t\t\telse {",
			"\t\t\t\t\tsum += (n->right ? n->right->child_size : 0) + 1;",
			"\t\t\t\t\tq.emplace(LEFT, n->left);",
			"\t\t\t\t}",
			"\t\t\t} else /* if (status == RIGHT) */{",
			"\t\t\t\tif (Compare()(v, *(n->key))) q.emplace(RIGHT, n->left);",
			"\t\t\t\telse {",
			"\t\t\t\t\tsum += (n->left ? n->left->child_size : 0) + 1;",
			"\t\t\t\t\tq.emplace(RIGHT, n->right);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn sum;",
			"\t}",
			"\tint count(const T& v) {",
			"\t\treturn count((T&&) v);",
			"\t}",
			"\tbool is_balanced() {",
			"\t\tauto dfs = [&](auto f, NODE* n, int& height, int& c_size) {",
			"\t\t\tif (0) return false;",
			"\t\t\tif (n == nullptr) {",
			"\t\t\t\theight = 0;",
			"\t\t\t\tc_size = 0;",
			"\t\t\t\treturn true;",
			"\t\t\t}",
			"\t\t\tint L = 0, R = 0;",
			"\t\t\tc_size = 1;",
			"\t\t\tint t;",
			"\t\t\tif (!f(f, n->left, L, t)) return false;",
			"\t\t\tc_size += t;",
			"\t\t\tif (!f(f, n->right, R, t)) return false;",
			"\t\t\tc_size += t;",
			"\t\t\theight = max(L, R) + 1;",
			"\t\t\tif (n->height != height) {",
			"\t\t\t\tcerr << \"hight value is odd.\" << endl;",
			"\t\t\t\treturn false;",
			"\t\t\t}",
			"\t\t\tif (n->bias() < -2 || n->bias() > 2) {",
			"\t\t\t\tcerr << \"bias value is odd.\" << endl;",
			"\t\t\t\tcerr << \"bias : \" << n->bias() << endl;",
			"\t\t\t\treturn false;",
			"\t\t\t}",
			"\t\t\tif (c_size != n->child_size) {",
			"\t\t\t\tcerr << \"child_size is wrong\" << endl;",
			"\t\t\t\tcerr << \"size : \" << n->child_size << endl;",
			"\t\t\t\tcerr << \"real : \" << c_size << endl;",
			"\t\t\t\treturn false;",
			"\t\t\t}",
			"\t\t\theight = std::max(L, R) + 1;",
			"\t\t\treturn true;",
			"\t\t};",
			"\t\tint t, u;",
			"\t\treturn dfs(dfs, node_dummy.left, t, u);",
			"\t}",
			"\titerator begin() {",
			"\t\treturn iterator(list_dummy.fp);",
			"\t}",
			"\titerator end() {",
			"\t\treturn iterator(&list_dummy);",
			"\t}",
			"\titerator lower_bound(T&& v) {",
			"\t\tNODE* now = node_dummy.left;",
			"\t\tNODE* ans = nullptr;",
			"\t\twhile (now != nullptr) {",
			"\t\t\tif (Compare()(*(now->key), v)) {",
			"\t\t\t\tnow = now->right;",
			"\t\t\t}",
			"\t\t\telse {",
			"\t\t\t\tans = now;",
			"\t\t\t\tnow = now->left;",
			"\t\t\t}",
			"\t\t}",
			"\t\tif (ans) return iterator(ans->index);",
			"\t\treturn iterator(&list_dummy);",
			"\t}",
			"\titerator lower_bound(const T& v) {",
			"\t\treturn lower_bound((T&&) v);",
			"\t}",
			"\titerator upper_bound(T&& v) {",
			"\t\tNODE* now = node_dummy.left;",
			"\t\tNODE* ans = nullptr;",
			"\t\twhile (now != nullptr) {",
			"\t\t\tif (Compare()(v, *(now->key))) {",
			"\t\t\t\tans = now;",
			"\t\t\t\tnow = now->left;",
			"\t\t\t}",
			"\t\t\telse {",
			"\t\t\t\tnow = now->right;",
			"\t\t\t}",
			"\t\t}",
			"\t\tif (ans) return iterator(ans->index);",
			"\t\treturn iterator(&list_dummy);",
			"\t}",
			"\titerator upper_bound(const T& v) {",
			"\t\treturn upper_bound((T&&) v);",
			"\t}",
			"\tconst T& get_kth_element(int k) {",
			"\t\tif (k < 0 || size() <= k) throw out_of_range(\"Error at AVLSet::get_kth_element(int)\");",
			"\t\tint pos = 0;",
			"\t\tNODE* now = node_dummy.left;",
			"\t\twhile (true) {",
			"\t\t\tint L = now->left ? now->left->child_size : 0;",
			"\t\t\tif (Compare()(pos + L, k)) pos += L + 1, now = now->right;",
			"\t\t\telse if (Compare()(k, L + pos)) now = now->left;",
			"\t\t\telse break;",
			"\t\t}",
			"\t\treturn *(now->key);",
			"\t}",
			"};",
			"template<class T>",
			"class AVLSetIterator {",
			"\tfriend AVLSet<T>;",
			"\tusing NODE_LIST = typename AVLSet<T>::NODE_LIST;",
			"\tNODE_LIST* list_ptr;",
			"\tAVLSetIterator(NODE_LIST* n) : list_ptr(n) {}",
			"public:",
			"\tAVLSetIterator(const AVLSetIterator& R) : list_ptr(R.list_ptr) {}",
			"\tAVLSetIterator& operator++() {",
			"\t\tif (list_ptr->dummy) throw out_of_range(\"Error at AVLSetIterator& operator++()\");",
			"\t\tlist_ptr = list_ptr->fp;",
			"\t\treturn *this;",
			"\t}",
			"\tAVLSetIterator operator++(int unused) {",
			"\t\tif (list_ptr->dummy) throw out_of_range(\"Error at AVLSetIterator operator++(int)\");",
			"\t\tAVLSetIterator result = *this;",
			"\t\tlist_ptr = list_ptr->fp;",
			"\t\treturn result;",
			"\t}",
			"\tAVLSetIterator& operator--() {",
			"\t\tif (list_ptr->bp->dummy) throw out_of_range(\"Error at AVLSetIterator& operator--()\");",
			"\t\tlist_ptr = list_ptr->bp;",
			"\t\treturn *this;",
			"\t}",
			"\tAVLSetIterator operator--(int unused) {",
			"\t\tif (list_ptr->bp->dummy) throw out_of_range(\"Error at AVLSetIterator operator--(int)\");",
			"\t\tAVLSetIterator result = *this;",
			"\t\tlist_ptr = list_ptr->bp;",
			"\t\treturn result;",
			"\t}",
			"\tint operator-(const AVLSetIterator& R) {",
			"\t\treturn list_ptr->get_position() - R.list_ptr->get_position();",
			"\t}",
			"\tconst T& operator*() const {",
			"\t\tassert(list_ptr->node->key);",
			"\t\treturn *(list_ptr->node->key);",
			"\t}",
			"\tbool operator==(const AVLSetIterator& R) {",
			"\t\treturn this->list_ptr == R.list_ptr;",
			"\t}",
			"\tbool operator!=(const AVLSetIterator& R) {",
			"\t\treturn !(*this == R);",
			"\t}",
			"};",
			"} // namespace",
			"",
			"using namespace spihill;",
			"",
			"void check_insert(const int);",
			"void check_erase(const int);",
			"bool check(AVLSet<int>& R, multiset<int>& S);",
			"",
			"int main()",
			"{",
			"\tcout << \"INSERT TEST\" << endl;",
			"\tcheck_insert(100000);",
			"\tcout << \"TEST PASSED\" << endl;",
			"\tcout << \"ERASE TEST\" << endl;",
			"\tcheck_erase(100000);",
			"\tcout << \"TEST PASSED\" << endl;",
			"}",
			"",
			"void check_insert(const int MAX)",
			"{",
			"\tAVLSet<int> R_random_big;",
			"\tAVLSet<int> R_random_small;",
			"\tAVLSet<int> R_increase;",
			"\tAVLSet<int> R_decrease;",
			"",
			"\tmultiset<int> S_random_big;",
			"\tmultiset<int> S_random_small;",
			"\tmultiset<int> S_increase;",
			"\tmultiset<int> S_decrease;",
			"",
			"\tstd::random_device seed_gen;",
			"\tstd::mt19937 engine(seed_gen());",
			"",
			"\tstd::uniform_real_distribution<> dist1(-1.0, 1.0);",
			"",
			"\tfor (int i = -MAX; i < MAX; i++) {",
			"\t\tint big = 1000000000 * dist1(engine);",
			"\t\tint small = 100 * dist1(engine);",
			"\t\tR_random_big.insert(big);",
			"\t\tR_random_small.insert(small);",
			"\t\tR_increase.insert(i);",
			"\t\tR_decrease.insert(-i);",
			"\t\tS_random_big.insert(big);",
			"\t\tS_random_small.insert(small);",
			"\t\tS_increase.insert(i);",
			"\t\tS_decrease.insert(-i);",
			"\t}",
			"",
			"\tauto R_copy(R_random_big);",
			"\tauto S_copy = S_random_big;",
			"\tAVLSet<int> R_assign;",
			"\tR_assign = R_random_big;",
			"\tfor (int i = -MAX; i < MAX; i++) {",
			"\t\tint big = 1000000000 * dist1(engine);",
			"\t\tR_copy.insert(big);",
			"\t\tR_assign.insert(big);",
			"\t\tS_copy.insert(big);",
			"\t}",
			"\tassert(check(R_increase, S_increase));",
			"\tassert(check(R_decrease, S_decrease));",
			"\tassert(check(R_random_big, S_random_big));",
			"\tassert(check(R_random_small, S_random_small));",
			"\tassert(check(R_copy, S_copy));",
			"\tassert(check(R_assign, S_copy));",
			"\tassert(R_increase.is_balanced());",
			"\tassert(R_decrease.is_balanced());",
			"\tassert(R_random_big.is_balanced());",
			"\tassert(R_random_small.is_balanced());",
			"\tassert(R_copy.is_balanced());",
			"\tassert(R_assign.is_balanced());",
			"\treturn;",
			"}",
			"",
			"",
			"void check_erase(const int MAX)",
			"{",
			"\tAVLSet<int> R_random_small;",
			"\tAVLSet<int> R_increase;",
			"\tAVLSet<int> R_decrease;",
			"\tAVLSet<int> R_nothing;",
			"",
			"\tmultiset<int> S_random_small;",
			"\tmultiset<int> S_increase;",
			"\tmultiset<int> S_decrease;",
			"\tmultiset<int> S_nothing;",
			"",
			"\tstd::random_device seed_gen;",
			"\tstd::mt19937 engine(seed_gen());",
			"",
			"\tstd::uniform_real_distribution<> dist1(-1.0, 1.0);",
			"",
			"\tfor (int i = -MAX; i < MAX; i++) {",
			"\t\tint big = 1000000000 * dist1(engine);",
			"\t\tint small = 100 * dist1(engine);",
			"\t\tR_random_small.insert(small);",
			"\t\tR_increase.insert(i);",
			"\t\tR_decrease.insert(i);",
			"\t\tR_nothing.insert(big);",
			"\t\tS_random_small.insert(small);",
			"\t\tS_increase.insert(i);",
			"\t\tS_decrease.insert(i);",
			"\t}",
			"\tfor (int i = 0; i < MAX; i++) {",
			"\t\tR_increase.erase(-i - 1);",
			"\t\tR_decrease.erase(i);",
			"\t\tS_increase.erase(-i - 1);",
			"\t\tS_decrease.erase(i);",
			"\t}",
			"",
			"\tfor (int i = -100; i <= 100; i++) {",
			"\t\tassert(R_random_small.count(i) == (int) S_random_small.count(i));",
			"\t\tassert((int) S_random_small.count(i) == R_random_small.upper_bound(i) - R_random_small.lower_bound(i));",
			"\t}",
			"",
			"\tfor (int i = 0; i < 10; i++) {",
			"\t\tint small = 100 * dist1(engine);",
			"\t\twhile (R_random_small.erase(small) != R_random_small.end());",
			"\t\tS_random_small.erase(small);",
			"\t}",
			"",
			"\tfor (int i = -100; i <= 100; i++) {",
			"\t\tassert(R_random_small.count(i) == (int) S_random_small.count(i));",
			"\t\tassert((int) S_random_small.count(i) == R_random_small.upper_bound(i) - R_random_small.lower_bound(i));",
			"\t}",
			"",
			"",
			"\twhile (R_nothing.erase(*(R_nothing.begin())) != R_nothing.end());",
			"",
			"\tassert(check(R_increase, S_increase));",
			"\tassert(check(R_decrease, S_decrease));",
			"\tassert(check(R_random_small, S_random_small));",
			"\tassert(check(R_nothing, S_nothing));",
			"\tassert(R_increase.is_balanced());",
			"\tassert(R_random_small.is_balanced());",
			"\tassert(R_decrease.is_balanced());",
			"\treturn;",
			"}",
			"",
			"bool check(AVLSet<int>& A, multiset<int>& S)",
			"{",
			"\tauto S_itr = S.begin();",
			"\tauto A_itr = A.begin();",
			"\tfor (;A_itr != A.end(); S_itr++, A_itr++) {",
			"\t\tif (*S_itr != *A_itr) return false;",
			"\t}",
			"\treturn S_itr == S.end();",
			"}"
		]
	},
	"Bellmanford": {
		"prefix": "Bellmanford",
		"body": [
			"using bellman_cost = $1;",
			"template<class V, class E>",
			"struct Graph",
			"{",
			"\tint sz;",
			"\tvector<V> v;",
			"\tvector<vector<E>> e;",
			"\tGraph(int n) : sz(n), v(n), e(n) {}",
			"\ttemplate<class... Args>",
			"\tinline void assign_vertex(int pos, Args... args) {",
			"\t\tv[pos] = V(args...);",
			"\t}",
			"\t// from, to, cost",
			"\ttemplate<class... Args>",
			"\tinline void add_edge(int pos, Args... args) {",
			"\t\te[pos].emplace_back(args...);",
			"\t}",
			"\tinline int size() {",
			"\t\treturn sz;",
			"\t}",
			"};",
			"",
			"template<class T>",
			"struct Vertex",
			"{",
			"\tT cost;",
			"\tbool valid = false; // \u5230\u9054\u4e0d\u80fd\u307e\u305f\u306f\u7121\u9650\u306b\u30b3\u30b9\u30c8\u304c\u6e1b\u308b\u3068\u304dfalse",
			"\tVertex(T v1) : cost(v1) {}",
			"\tVertex() {}",
			"};",
			"using vertex = Vertex<bellman_cost>;",
			"",
			"template<class T>",
			"struct Edge",
			"{",
			"\tint to;",
			"\tT cost;",
			"\tEdge(int t, T c) : to(t), cost(c) {}",
			"\tEdge() {}",
			"};",
			"using edge = Edge<bellman_cost>;",
			"using graph = Graph<vertex, edge>;",
			"",
			"template<class V, class E>",
			"void Bellmanford(Graph<V, E>& G, int s, bellman_cost INF_COST)",
			"{",
			"\tauto &v = G.v;",
			"\tauto &e = G.e;",
			"\tfor (auto& vv : v) vv.cost = INF_COST, vv.valid = false;",
			"\tv[s].cost = 0, v[s].valid = true;",
			"\tfor (int i = 0; i + 1 < (int) v.size(); i++) {",
			"\t\tfor (int j = 0; j < (int) v.size(); j++) {",
			"\t\t\tfor (auto& x: e[j]) {",
			"\t\t\t\tif (v[j].cost == INF_COST) continue;",
			"\t\t\t\tv[x.to].cost = min(v[x.to].cost, v[j].cost + x.cost);",
			"\t\t\t\tv[x.to].valid = true;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tauto valid_check = [&](auto f, int pos) {",
			"\t\tif (!v[pos].valid) return;",
			"\t\tv[pos].valid = false;",
			"\t\tfor (auto& y: e[pos]) {",
			"\t\t\tf(f, y.to);",
			"\t\t}",
			"\t};",
			"\tfor (int i = 0; i < (int) v.size(); i++) {",
			"\t\tfor (auto& x: e[i]) {",
			"\t\t\tif (v[i].cost == INF_COST) continue;",
			"\t\t\tif (v[x.to].cost > v[i].cost + x.cost) {",
			"\t\t\t\tvalid_check(valid_check, x.to);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"}"
		]
	},
	"BIT": {
		"prefix": "BIT",
		"body": [
			"template<class T>",
			"struct BIT {",
			"\tint n;",
			"\tvector<T> bit;",
			"\tBIT(int n_) {",
			"\t\tn = n_;",
			"\t\tbit.resize(n+1);",
			"\t}",
			"\tvoid add(int x, T v) {",
			"\t\tfor (int i = x+1; i <= n; i += i & -i) {",
			"\t\t\tbit[i] += v;",
			"\t\t}",
			"\t}",
			"\tT get(int x) {",
			"\t\tT res = 0;",
			"\t\tfor (int i = x+1; i; i -= i & -i) {",
			"\t\t\tres += bit[i];",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"};"
		]
	},
	"BIT_2D": {
		"prefix": "BIT_2D",
		"body": [
			"template<class T>",
			"struct BIT_2D {",
			"\tint R, C;",
			"\tvector<vector<T>> bit;",
			"\tBIT_2D(int r, int c) {",
			"\t\tR = r;",
			"\t\tC = c;",
			"\t\tbit.resize(r+1, vector<T>(c+1, 0));",
			"\t}",
			"\tvoid add(int r, int c, T v) {",
			"\t\tfor (int i = r+1; i <= R; i += i & -i) {",
			"\t\t\tfor (int j = c+1; j <= C; j += j & -j) {",
			"\t\t\t\tbit[i][j] += v;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tT get(int r, int c) {",
			"\t\tT res = 0;",
			"\t\tfor (int i = r+1; i; i -= i & -i) {",
			"\t\t\tfor (int j = c+1; j; j -= j & -j) {",
			"\t\t\t\tres += bit[i][j];",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"// bit[r1][c1] ~~ bit[r2 - 1][c2 - 1]",
			"\tT get_sum(int r1, int c1, int r2, int c2) {",
			"\t\tr1--; c1--; r2--; c2--;",
			"\t\treturn get(r2, c2) - get(r1, c2) - get(r2, c1) + get(r1, c1);",
			"\t}",
			"};"
		]
	},
	"class2": {
		"prefix": "class2",
		"body": [
			"struct $1",
			"{",
			"\t$2 $4;",
			"\t$3 $5;",
			"\t$1($2 v1, $3 v2) : $4(v1), $5(v2) {}",
			"\t$1() {}",
			"\tbool operator<(const $1 r) const {",
			"\t\treturn $4 == r.$4 ? $5 < r.$5 : $4 < r.$4;",
			"\t}",
			"\tbool operator>(const $1 r) const {",
			"\t\treturn r < *this;",
			"\t}",
			"\tbool operator>=(const $1 r) const {",
			"\t\treturn !(*this < r);",
			"\t}",
			"\tbool operator<=(const $1 r) const {",
			"\t\treturn !(r < *this);",
			"\t}",
			"\tbool operator==(const $1 r) const {",
			"\t\treturn !(r < *this) && !(*this < r);",
			"\t}",
			"\tbool operator!=(const $1 r) const {",
			"\t\treturn (r < *this) || (*this < r);",
			"\t}",
			"};"
		]
	},
	"class3": {
		"prefix": "class3",
		"body": [
			"struct $1",
			"{",
			"\t$2 $5;",
			"\t$3 $6;",
			"\t$4 $7;",
			"\t$1($2 v1, $3 v2, $4 v3) : $5(v1), $6(v2), $7(v3) {}",
			"\t$1() {}",
			"\tbool operator<(const $1 r) const {",
			"\t\tif ($5 == r.$5) {",
			"\t\t\tif ($6 == r.$6) {",
			"\t\t\t\treturn $7 < r.$7;",
			"\t\t\t} else {",
			"\t\t\t\treturn $6 < r.$6;",
			"\t\t\t}",
			"\t\t} else {",
			"\t\t\treturn $5 < r.$5;",
			"\t\t}",
			"\t}",
			"\tbool operator>(const $1 r) const {",
			"\t\treturn r < *this;",
			"\t}",
			"\tbool operator>=(const $1 r) const {",
			"\t\treturn !(*this < r);",
			"\t}",
			"\tbool operator<=(const $1 r) const {",
			"\t\treturn !(r < *this);",
			"\t}",
			"\tbool operator==(const $1 r) const {",
			"\t\treturn !(r < *this) && !(*this < r);",
			"\t}",
			"\tbool operator!=(const $1 r) const {",
			"\t\treturn (r < *this) || (*this < r);",
			"\t}",
			"};"
		]
	},
	"class4": {
		"prefix": "class4",
		"body": [
			"struct $1",
			"{",
			"\t$2 $6;",
			"\t$3 $7;",
			"\t$4 $8;",
			"\t$5 $9; ",
			"\t$1($2 v1, $3 v2, $4 v3, $5 v4) : $6(v1), $7(v2), $8(v3) , $9(v4) {}",
			"\t$1() {}",
			"\tbool operator<(const $1 r) const {",
			"\t\tif ($6 == r.$6) {",
			"\t\t\tif ($7 == r.$7) {",
			"\t\t\t\tif ($8 == r.$8) {",
			"\t\t\t\t\treturn $9 < r.$9;",
			"\t\t\t\t} else {",
			"\t\t\t\t\treturn $8 < r.$8;",
			"\t\t\t\t}",
			"\t\t\t} else {",
			"\t\t\t\treturn $7 < r.$7;",
			"\t\t\t}",
			"\t\t} else {",
			"\t\t\treturn $6 < r.$6;",
			"\t\t}",
			"\t}",
			"\tbool operator>(const $1 r) const {",
			"\t\treturn r < *this;",
			"\t}",
			"\tbool operator>=(const $1 r) const {",
			"\t\treturn !(*this < r);",
			"\t}",
			"\tbool operator<=(const $1 r) const {",
			"\t\treturn !(r < *this);",
			"\t}",
			"\tbool operator==(const $1 r) const {",
			"\t\treturn !(r < *this) && !(*this < r);",
			"\t}",
			"\tbool operator!=(const $1 r) const {",
			"\t\treturn (r < *this) || (*this < r);",
			"\t}",
			"};"
		]
	},
	"class5": {
		"prefix": "class5",
		"body": [
			"struct $1",
			"{",
			"\t$2 $7;",
			"\t$3 $8;",
			"\t$4 $9;",
			"\t$5 $10; ",
			"\t$6 $11;",
			"\t$1($2 v1, $3 v2, $4 v3, $5 v4, $6 v5) : $7(v1), $8(v2), $9(v3), $10(v4), $11(v5) {}",
			"\t$1() {}",
			"\tbool operator<(const $1 r) const {",
			"\t\tif ($7 == r.$7) {",
			"\t\t\tif ($8 == r.$8) {",
			"\t\t\t\tif ($9 == r.$9) {",
			"\t\t\t\t\tif ($10 == r.$10) {",
			"\t\t\t\t\t\treturn $11 < r.$11;",
			"\t\t\t\t\t} else {",
			"\t\t\t\t\t\treturn $10 < r.$10;",
			"\t\t\t\t\t}",
			"\t\t\t\t} else {",
			"\t\t\t\t\treturn $9 < r.$9;",
			"\t\t\t\t}",
			"\t\t\t} else {",
			"\t\t\t\treturn $8 < r.$8;",
			"\t\t\t}",
			"\t\t} else {",
			"\t\t\treturn $7 < r.$7;",
			"\t\t}",
			"\t}",
			"\tbool operator>(const $1 r) const {",
			"\t\treturn r < *this;",
			"\t}",
			"\tbool operator>=(const $1 r) const {",
			"\t\treturn !(*this < r);",
			"\t}",
			"\tbool operator<=(const $1 r) const {",
			"\t\treturn !(r < *this);",
			"\t}",
			"\tbool operator==(const $1 r) const {",
			"\t\treturn !(r < *this) && !(*this < r);",
			"\t}",
			"\tbool operator!=(const $1 r) const {",
			"\t\treturn (r < *this) || (*this < r);",
			"\t}",
			"};"
		]
	},
	"Dijkstra": {
		"prefix": "Dijkstra",
		"body": [
			"using dijkstra_cost = $1;",
			"",
			"template<class V, class E>",
			"struct Graph",
			"{",
			"\tint sz;",
			"\tvector<V> v;",
			"\tvector<vector<E>> e;",
			"\tGraph(int n) : sz(n), v(n), e(n) {}",
			"\ttemplate<class... Args>",
			"\tinline void assign_vertex(int pos, Args... args) {",
			"\t\tv[pos] = V(args...);",
			"\t}",
			"\ttemplate<class... Args>",
			"\tinline void add_edge(int pos, Args... args) {",
			"\t\te[pos].emplace_back(args...);",
			"\t}",
			"\tinline int size() {",
			"\t\treturn sz;",
			"\t}",
			"};",
			"",
			"template<class T>",
			"struct Vertex",
			"{",
			"\tT cost;",
			"\tVertex(T v1) : cost(v1) {}",
			"\tVertex() {}",
			"};",
			"using vertex = Vertex<dijkstra_cost>;",
			"",
			"template<class T>",
			"struct Edge",
			"{",
			"\tint to;",
			"\tT cost;",
			"\tEdge(int t, T c) : to(t), cost(c) {}",
			"\tEdge() {}",
			"};",
			"using edge = Edge<dijkstra_cost>;",
			"using graph = Graph<vertex, edge>;",
			"",
			"template<class V, class E>",
			"void Dijkstra(Graph<V, E>& G, int s, dijkstra_cost INF_COST)",
			"{",
			"\tauto &v = G.v;",
			"\tauto &e = G.e;",
			"\tfor (auto& vv : v) vv.cost = INF_COST;",
			"\tusing Q_T = pair<dijkstra_cost, int>;",
			"\tpriority_queue<Q_T, vector<Q_T>, greater<>> q;",
			"\tq.emplace(0, s);",
			"\twhile (!q.empty()) {",
			"\t\tauto a = q.top();",
			"\t\tq.pop();",
			"\t\tif (a.first >= v[a.second].cost) continue;",
			"\t\tv[a.second].cost = a.first;",
			"\t\tfor (auto& p : e[a.second]) {",
			"\t\t\tif (p.cost == INF_COST) continue;",
			"\t\t\tif (a.first + p.cost < v[p.to].cost) q.emplace(a.first + p.cost, p.to);",
			"\t\t}",
			"\t}",
			"}"
		]
	},
	"Dinic": {
		"prefix": "Dinic",
		"body": [
			"template<class T>",
			"// O(|E||V|^2)",
			"struct Dinic {",
			"\tconst T FLOW_INF = INT_MAX;",
			"\tedges v;",
			"\tvector<int> level;",
			"\tvector<int> iter;",
			"// a:Vertex(|V|)",
			"\tDinic(int a) : level(a), iter(a) {",
			"\t\tv.init(a);",
			"\t}",
			"// x:from y:to z:capacity",
			"\tvoid add_edge(int x, int y, T z) {",
			"\t\tv.add_edge(edge(x, y, z, v[y].size()));",
			"\t\tv.add_edge(edge(y, x, 0, v[x].size()-1));",
			"\t}",
			"\tT dfs(int s, int t, T f) {",
			"\t\tif (s == t) return f;",
			"\t\tfor (int& i = iter[s]; i < (int) v[s].size(); i++) {",
			"\t\t\tauto& x = v[s][i];",
			"\t\t\tif (x.cap == 0 || level[s] >= level[x.to]) continue;",
			"\t\t\tT d;",
			"\t\t\tif ((d = dfs(x.to, t, min(f, x.cap))) > 0) {",
			"\t\t\t\tx.cap -= d;",
			"\t\t\t\tv[x.to][x.rev].cap += d;",
			"\t\t\t\treturn d;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn 0;",
			"\t}",
			"\tvoid bfs(int s) {",
			"\t\tfill(level.begin(), level.end(), -1);",
			"\t\tqueue<pair<int, int>> q;",
			"\t\tq.push(make_pair(s, 0));",
			"\t\twhile (!q.empty()) {",
			"\t\t\tauto x = q.front();",
			"\t\t\tq.pop();",
			"\t\t\tint a = x.first;",
			"\t\t\tint b = x.second;",
			"\t\t\tif (level[a] != -1) continue;",
			"\t\t\tlevel[a] = b;",
			"\t\t\tfor (auto y : v[a]) {",
			"\t\t\t\tif (y.cap > 0) q.push(make_pair(y.to, b+1));",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tT calc(int s, int t) {",
			"\t\tT res = 0;",
			"\t\twhile (true){",
			"\t\t\tbfs(s);",
			"\t\t\tif (level[t] < 0) return res;",
			"\t\t\tfill(iter.begin(), iter.end(), 0);",
			"\t\t\tT r;",
			"\t\t\tdo {",
			"\t\t\t\tr = dfs(s, t, FLOW_INF);",
			"\t\t\t\tres += r;",
			"\t\t\t} while (r);",
			"\t\t}",
			"\t}",
			"};"
		]
	},
	"Edges_List": {
		"prefix": "Edges_List",
		"body": [
			"template<class Edge>",
			"struct Edges_List {",
			"\tvector<vector<Edge>> E;",
			"\tint n;",
			"\tvoid init(int sz) {",
			"\t\tn = sz;",
			"\t\tE.resize(sz);",
			"\t}",
			"\tvoid add_edge(Edge e) {",
			"\t\tE[e.from].emplace_back(e);",
			"\t}",
			"\tvector<Edge>& operator[](int x) {",
			"\t\treturn E[x];",
			"\t}",
			"\tsize_t size() {",
			"\t\treturn n;",
			"\t}",
			"};",
			"using edges = Edges_List<edge>;",
			"/*",
			"\tDepends on ",
			"\t\t- Edge_Cost or Edge_Cap_Rev",
			"*/"
		]
	},
	"Edges_Matrix": {
		"prefix": "Edges_Matrix",
		"body": [
			"template<class Edge>",
			"struct Edges_Matrix {",
			"\tvector<vector<Edge>> E;",
			"\tint n;",
			"\tvoid init(int sz) {",
			"\t\tn = sz;",
			"\t\tE.resize(n, vector<Edge>(n));",
			"\t\tfor (int i = 0; i < n; i++) {",
			"\t\t\tfor (int j = 0; j < n; j++) {",
			"\t\t\t\tE[i][j].from = i;",
			"\t\t\t\tE[i][j].to = j;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tvoid add_edge(Edge e) {",
			"\t\tE[from][to] = e;",
			"\t}",
			"\tvector<Edge>& operator[](int x) {",
			"\t\treturn E[x];",
			"\t}",
			"\tsize_t size() {",
			"\t\treturn n;",
			"\t}",
			"};",
			"using edges = Edges_Matrix<edge>;",
			"/*",
			"\tDepends on ",
			"\t\t- Edge_Cost or Edge_Cap_Rev",
			"*/"
		]
	},
	"Edge_Cap_Rev": {
		"prefix": "Edge_Cap_Rev",
		"body": [
			"template<class CAP_T>",
			"struct Edge_Cap_Rev {",
			"\tint from;",
			"\tint to;",
			"\tCAP_T cap;",
			"\tint rev;",
			"\tEdge_Cap_Rev(int x, int y, CAP_T z, int w) : from(x), to(y), cap(z), rev(w) {}",
			"};",
			"using edge = Edge_Cap_Rev<>;"
		]
	},
	"Edge_Cost": {
		"prefix": "Edge_Cost",
		"body": [
			"template<class COST_T>",
			"struct Edge_Cost {",
			"\tint from;",
			"\tint to;",
			"\tCOST_T cost;",
			"\tEdge_Cost(int from_, int to_, COST_T cost_) : from(from_), to(to_), cost(cost_) {}",
			"\tEdge_Cost(void) : from(0), to(0), cost(0) {}",
			"\tinline bool operator<(const Edge_Cost a) const {",
			"\t\treturn cost < a.cost;",
			"\t}",
			"\tinline bool operator>(const Edge_Cost a) const {",
			"\t\treturn a < (*this);",
			"\t}",
			"};",
			"using edge = Edge_Cost<>;"
		]
	},
	"Ford_Fulkerson": {
		"prefix": "Ford_Fulkerson",
		"body": [
			"struct Ford_Fulkerson {",
			"\tedges& v;",
			"\tvector<bool> used;",
			"\tint n;",
			"\tconst int INF = INT_MAX;",
			"// a:Vertex(|V|)",
			"\tFord_Fulkerson(edges& a) : v(a) {",
			"\t\tn = a.size();",
			"\t\tused.resize(n);",
			"\t}",
			"// x:from y:to z:capacity",
			"\tvoid add_edge(int x, int y, int z) {",
			"\t\tv.add_edge(edge(x, y, z, v[y].size()));",
			"\t\tv.add_edge(edge(y, x, 0, v[x].size()-1));",
			"\t}",
			"\tint dfs(int s, int t, int f) {",
			"\t\tif (used[s]) return 0;",
			"\t\tused[s] = true;",
			"\t\tif (s == t) return f;",
			"\t\tfor (auto& x : v[s]) {",
			"\t\t\tif (x.cap == 0) continue;",
			"\t\t\tint ret = dfs(x.to, t, min(f, x.cap));",
			"\t\t\tif (ret > 0) {",
			"\t\t\t\tx.cap -= ret;",
			"\t\t\t\tv[x.to][x.rev].cap += ret;",
			"\t\t\t\treturn ret;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn 0;",
			"\t}",
			"\tint calc(int s, int t) {",
			"\t\tint res = 0;",
			"\t\twhile (true){",
			"\t\t\tfill(used.begin(), used.end(), false);",
			"\t\t\tint r = dfs(s, t, INF);",
			"\t\t\tif (r == 0) break;",
			"\t\t\tres += r;",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"};",
			"/*",
			"\tDepends on",
			"\t\t- Edge_Cap_Rev",
			"\t\t- Edges_List",
			"*/"
		]
	},
	"LazySegTree": {
		"prefix": "LazySegTree",
		"body": [
			"template <class NODE, class LAZY, NODE UNITY_NODE, LAZY UNITY_LAZY>",
			"struct LazySegTree {",
			"// edit start",
			"\tNODE merge(NODE a, NODE b) {",
			"//\t\treturn a + b;",
			"\t}",
			"\tLAZY add(LAZY a, LAZY b) {",
			"//\t\treturn a + b;",
			"\t}",
			"\tNODE reflect(NODE a, LAZY b) {",
			"//\t\treturn a + b;",
			"\t}",
			"\tLAZY propagate(LAZY a, int len) {",
			"//\t\treturn a;",
			"//\t\treturn a * len;",
			"\t}",
			"// edit end",
			"\tint n;",
			"\tvector<NODE> node;",
			"\tvector<LAZY> lazy;",
			"\tLazySegTree(int n_) {",
			"\t\tinit(n_);",
			"\t}",
			"\tinline void eval(int len, int k) {",
			"\t\tif (lazy[k] == UNITY_LAZY) return;",
			"\t\tif (k*2 + 1 < n*2 - 1) {",
			"\t\t\tlazy[k*2+1] = add(lazy[k*2+1], lazy[k]);",
			"\t\t\tlazy[k*2+2] = add(lazy[k*2+2], lazy[k]);",
			"\t\t}",
			"\t\tnode[k] = reflect(node[k], propagate(lazy[k], len));",
			"\t\tlazy[k] = UNITY_LAZY;",
			"\t}",
			"\tvoid init(int n_) {",
			"\t\tn = 1;",
			"\t\twhile (n < n_) n *= 2;",
			"\t\tnode.clear();",
			"\t\tlazy.clear();",
			"\t\tnode.assign(2*n-1, UNITY_NODE);",
			"\t\tlazy.assign(2*n-1, UNITY_LAZY);",
			"\t}",
			"\tvoid build(vector<NODE>& v, int n_ = -1) {",
			"\t\tif (n_ == -1) n_ = v.size();",
			"\t\tfor (int i = 0; i < n_; i++) node[i+n-1] = v[i];",
			"\t\tfor (int i = n-2; i >= 0; i--) node[i] = merge(node[i*2+1], node[i*2+2]);",
			"\t}",
			"\tNODE set(int a, int b, LAZY x, int k, int l, int r) {",
			"\t\teval(r-l, k);",
			"\t\tif (b <= l || r <= a) return node[k];",
			"\t\tif (a <= l && r <= b) {",
			"\t\t\tlazy[k] = add(lazy[k], x);",
			"\t\t\treturn reflect(node[k], propagate(lazy[k], r-l));",
			"\t\t}",
			"\t\treturn node[k] = merge(set(a, b, x, k*2+1, l, (l+r)/2),",
			"\t\t                       set(a, b, x, k*2+2, (l+r)/2, r));",
			"\t}",
			"\tNODE set(int a, int b, LAZY x) {",
			"\t\treturn set(a, b, x, 0, 0, n);",
			"\t}",
			"\tNODE get(int a, int b, int k, int l, int r) {",
			"\t\teval(r-l, k);",
			"\t\tif (b <= l || r <= a) return UNITY_NODE;",
			"\t\tif (a <= l && r <= b) return node[k];",
			"\t\tNODE vl = get(a, b, k*2+1, l, (l+r)/2);",
			"\t\tNODE vr = get(a, b, k*2+2, (l+r)/2, r);",
			"\t\treturn merge(vl, vr);",
			"\t}",
			"\tNODE get(int a, int b) {",
			"\t\treturn get(a, b, 0, 0, n);",
			"\t}",
			"/* Debug",
			"\tvoid print() {",
			"\t\tint x = 0;",
			"\t\tint nx = 2;",
			"\t\tcerr << \"NODE\" << endl;",
			"\t\tfor (int i = 0; i < 2 * n - 1; i++) {",
			"\t\t\tcerr << node[i] << \" \";",
			"\t\t\tif (i == x) {",
			"\t\t\t\tx += nx;",
			"\t\t\t\tnx *= 2;",
			"\t\t\t\tcerr << endl;",
			"\t\t\t}",
			"\t\t}",
			"\t\tx = 0;",
			"\t\tnx = 2;",
			"\t\tcerr << endl << endl;;",
			"\t\tcerr << \"LAZY\" << endl;",
			"\t\tfor (int i = 0; i < 2 * n - 1; i++) {",
			"\t\t\tcerr << lazy[i] << \" \";",
			"\t\t\tif (i == x) {",
			"\t\t\t\tx += nx;",
			"\t\t\t\tnx *= 2;",
			"\t\t\t\tcerr << endl;",
			"\t\t\t}",
			"\t\t}",
			"\t\tcerr << endl << endl;",
			"\t}",
			"*/",
			"};"
		]
	},
	"logpow": {
		"prefix": "logpow",
		"body": [
			"template<class T>",
			"T logpow(T x, long long p)",
			"{",
			"\tif (p == 0) {",
			"\t\treturn 1;",
			"\t}",
			"\tif (p % 2) {",
			"\t\treturn x * logpow(x, p-1);",
			"\t}",
			"\tT t = logpow(x, p/2);",
			"\treturn t * t;",
			"}"
		]
	},
	"Matrix": {
		"prefix": "Matrix",
		"body": [
			"template<class Edge>",
			"struct Edges_Matrix {",
			"\tvector<vector<Edge>> E;",
			"\tint n;",
			"\tvoid init(int sz) {",
			"\t\tn = sz;",
			"\t\tE.resize(n, vector<Edge>(n));",
			"\t\tfor (int i = 0; i < n; i++) {",
			"\t\t\tfor (int j = 0; j < n; j++) {",
			"\t\t\t\tE[i][j].from = i;",
			"\t\t\t\tE[i][j].to = j;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tvoid add_edge(Edge e) {",
			"\t\tE[e.from][e.to] = e;",
			"\t}",
			"\tvector<Edge>& operator[](int x) {",
			"\t\treturn E[x];",
			"\t}",
			"\tsize_t size() {",
			"\t\treturn n;",
			"\t}",
			"}",
			"using edges = Edges_Matrix<edge>;",
			"/*",
			"\tDepends on ",
			"\t\t- Edge_Cost or Edge_Cap_Rev",
			"*/;"
		]
	},
	"ModComb": {
		"prefix": "ModComb",
		"body": [
			"template<class T>",
			"struct ModComb {",
			"\tvector<T> fact;",
			"\tvector<T> facti;",
			"\tModComb(int n) : fact(n+1), facti(n+1) {",
			"\t\tfact[0] = 1;",
			"\t\tfor (int i = 1; i < n + 1; i++) {",
			"\t\t\tfact[i] = fact[i-1] * i;",
			"\t\t}",
			"\t\tfacti[n] = 1 / fact[n];",
			"\t\tfor (int i = n-1; i >= 0; i--) {",
			"\t\t\tfacti[i] = facti[i+1] * (i + 1);",
			"\t\t}",
			"\t}",
			"\tT C(int n, int r) const {",
			"\t\tif(n < 0 || r < 0 || n < r) return 0;",
			"\t\treturn fact[n] * facti[r] * facti[n-r];",
			"\t}",
			"\tT P(int n, int r) const {",
			"\t\tif(n < 0 || r < 0 || n < r) return 0;",
			"\t\treturn fact[n] * facti[n-r];",
			"\t}",
			"\tT H(int n, int r) const {",
			"\t\tif(n < 0 || r < 0) return 0;",
			"\t\treturn C(n + r - 1, r);",
			"\t}",
			"};",
			"using modcomb = ModComb<modint>;"
		]
	},
	"ModInt": {
		"prefix": "ModInt",
		"body": [
			"namespace mylib {",
			"template<int mod>",
			"struct ModInt {",
			"\tusing ll = long long;",
			"\tint x;",
			"\tconst static int M = mod;",
			"\tModInt(ll x_) {",
			"\t\tx = x_ % mod;",
			"\t\tif (x < 0) x += mod;",
			"\t}",
			"\tModInt() : ModInt(0) {}",
			"\tinline ModInt& operator+=(const ModInt rhs) {",
			"\t\tx += rhs.x;",
			"\t\tx %= mod;",
			"\t\treturn (*this);",
			"\t}",
			"\tinline ModInt& operator-=(const ModInt rhs) {",
			"\t\tx += -rhs;",
			"\t\treturn *this;",
			"\t}",
			"\tinline ModInt& operator*=(const ModInt rhs) {",
			"\t\tx = ((ll) x * rhs.x) % mod;",
			"\t\treturn *this;",
			"\t}",
			"\tinline ModInt& operator/=(ModInt rhs) {",
			"\t\treturn *this *= rhs.power(mod - 2);",
			"\t}",
			"\tinline ModInt power(ll p) {",
			"\t\tModInt res = 1;",
			"\t\tModInt a = x;",
			"\t\tfor (; p; res = p & 1 ? res * a : res, a *= a, p >>= 1);",
			"\t\treturn res;",
			"\t}",
			"\tinline ModInt& operator=(const ModInt& rhs) {",
			"\t\tthis->x = rhs.x;",
			"\t\treturn *this;",
			"\t}",
			"\tinline int operator==(const ModInt& rhs) const {",
			"\t\treturn this->x == rhs.x;",
			"\t}",
			"\tinline int operator!=(const ModInt& rhs) const {",
			"\t\treturn !(*this != rhs);",
			"\t}",
			"\tinline ModInt operator++(signed unused) {",
			"\t\tModInt res(*this);",
			"\t\t++(*this);",
			"\t\treturn res;",
			"\t}",
			"\tinline ModInt& operator++() {",
			"\t\t(*this) += 1;",
			"\t\treturn (*this);",
			"\t}",
			"\tinline ModInt operator--(signed unused) {",
			"\t\tModInt res(*this);",
			"\t\t--(*this);",
			"\t\treturn res;",
			"\t}",
			"\tinline ModInt& operator--() {",
			"\t\t(*this) -= 1;",
			"\t\treturn (*this);",
			"\t}",
			"\tinline ModInt operator+() const {",
			"\t\treturn (*this);",
			"\t}",
			"\tinline ModInt operator-() const {",
			"\t\treturn (*this).x ? ModInt(mod - (*this).x) : ModInt(0);",
			"\t}",
			"\tfriend const ModInt operator+(const ModInt& lhs, const ModInt& rhs) {return ModInt(lhs) += rhs;}",
			"\tfriend const ModInt operator-(const ModInt& lhs, const ModInt& rhs) {return ModInt(lhs) -= rhs;}",
			"\tfriend const ModInt operator*(const ModInt& lhs, const ModInt& rhs) {return ModInt(lhs) *= rhs;}",
			"\tfriend const ModInt operator/(const ModInt& lhs, const ModInt& rhs) {return ModInt(lhs) /= rhs;}",
			"\texplicit operator int() const {return x;}",
			"\tfriend ostream& operator<<(ostream& lhs, const ModInt& rhs) {",
			"\t\tlhs << rhs.x;",
			"\t\treturn lhs;",
			"\t}",
			"\tfriend istream& operator>>(istream& lhs, ModInt& rhs) {",
			"\t\tlong long t;",
			"\t\tlhs >> t;",
			"\t\trhs = ModInt(t);",
			"\t\treturn lhs;",
			"\t}",
			"};",
			"using modint = ModInt<1000000007>;",
			"//using modint = ModInt<998244353>;",
			"modint operator\"\" _mi(unsigned long long lit) {",
			"\treturn modint(lit % modint::M);",
			"}",
			"}; // mylib",
			"using namespace mylib;"
		]
	},
	"mylib": {
		"prefix": "mylib",
		"body": [
			"namespace mylib {",
			"",
			"}",
			"using namespace mylib;"
		]
	},
	"RedBlackSet": {
		"prefix": "RedBlackSet",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"using namespace std;",
			"",
			"namespace spihill {",
			"template<class T>",
			"class RedBlackSetIterator;",
			"",
			"template<class T, class Compare = less<T>>",
			"struct RedBlackSet {",
			"\tstruct NODE;",
			"\tstruct NODE_LIST;",
			"\tfriend RedBlackSetIterator<T>;",
			"\tusing iterator = RedBlackSetIterator<T>;",
			"\tNODE_LIST list_dummy;",
			"\tNODE node_dummy;",
			"\tRedBlackSet() {",
			"\t\tnode_dummy.index = &list_dummy;",
			"\t\tlist_dummy.node = &node_dummy;",
			"\t}",
			"\tRedBlackSet(const RedBlackSet& R) {",
			"\t\tnode_dummy.index = &list_dummy;",
			"\t\tnode_dummy.left_size = R.node_dummy.left_size;",
			"\t\tlist_dummy.node = &node_dummy;",
			"\t\tauto dfs = [&](auto f, NODE* old_node, NODE* new_node) {",
			"\t\t\tif (0) return new_node;",
			"\t\t\tif (old_node->left) {",
			"\t\t\t\tnew_node->left = f(f, old_node->left, new NODE((T&&) *(old_node->left->key), new_node));",
			"\t\t\t}",
			"\t\t\tauto l = new NODE_LIST(&list_dummy, true);",
			"\t\t\tl->node = new_node;",
			"\t\t\tnew_node->index = l;",
			"\t\t\tnew_node->red = old_node->red;",
			"\t\t\tnew_node->left_size = old_node->left_size;",
			"\t\t\tnew_node->right_size = old_node->right_size;",
			"\t\t\tif (old_node->right) {",
			"\t\t\t\tnew_node->right = f(f, old_node->right, new NODE((T&&) *(old_node->right->key), new_node));",
			"\t\t\t}",
			"\t\t\treturn new_node;",
			"\t\t};",
			"\t\tif (R.node_dummy.left) node_dummy.left = dfs(dfs, R.node_dummy.left, new NODE((T&&) *(R.node_dummy.left->key), &node_dummy));",
			"\t}",
			"\t~RedBlackSet() {",
			"\t\tfor (NODE_LIST* p = list_dummy.fp; p != &list_dummy;) {",
			"\t\t\tp = p->fp;",
			"\t\t\tdelete p->bp;",
			"\t\t}",
			"\t}",
			"\tint size() {",
			"\t\treturn node_dummy.left_size;",
			"\t}",
			"\titerator begin() {",
			"\t\treturn iterator(list_dummy.fp);",
			"\t}",
			"\titerator end() {",
			"\t\treturn iterator(&list_dummy);",
			"\t}",
			"\titerator lower_bound(T&& v) {",
			"\t\tNODE* now = node_dummy.left;",
			"\t\tNODE* ans = nullptr;",
			"\t\twhile (now != nullptr) {",
			"\t\t\tif (Compare()(*(now->key), v)) {",
			"\t\t\t\tnow = now->right;",
			"\t\t\t}",
			"\t\t\telse {",
			"\t\t\t\tans = now;",
			"\t\t\t\tnow = now->left;",
			"\t\t\t}",
			"\t\t}",
			"\t\tif (ans) return iterator(ans->index);",
			"\t\treturn iterator(&list_dummy);",
			"\t}",
			"\titerator lower_bound(const T& v) {",
			"\t\treturn lower_bound((T&&) v);",
			"\t}",
			"\titerator upper_bound(T&& v) {",
			"\t\tNODE* now = node_dummy.left;",
			"\t\tNODE* ans = nullptr;",
			"\t\twhile (now != nullptr) {",
			"\t\t\tif (Compare()(v, *(now->key))) {",
			"\t\t\t\tans = now;",
			"\t\t\t\tnow = now->left;",
			"\t\t\t}",
			"\t\t\telse {",
			"\t\t\t\tnow = now->right;",
			"\t\t\t}",
			"\t\t}",
			"\t\tif (ans) return iterator(ans->index);",
			"\t\treturn iterator(&list_dummy);",
			"\t}",
			"\titerator upper_bound(const T& v) {",
			"\t\treturn upper_bound((T&&) v);",
			"\t}",
			"\tRedBlackSet& operator=(const RedBlackSet& R) {",
			"\t\tfor (NODE_LIST* p = list_dummy.fp; p != &list_dummy;) {",
			"\t\t\tp = p->fp;",
			"\t\t\tdelete p->bp;",
			"\t\t}",
			"\t\tnode_dummy.index = &list_dummy;",
			"\t\tnode_dummy.left_size = R.node_dummy.left_size;",
			"\t\tlist_dummy.node = &node_dummy;",
			"\t\tauto dfs = [&](auto f, NODE* old_node, NODE* new_node) {",
			"\t\t\tif (0) return new_node;",
			"\t\t\tif (old_node->left) {",
			"\t\t\t\tnew_node->left = f(f, old_node->left, new NODE((T&&) *(old_node->left->key), new_node));",
			"\t\t\t}",
			"\t\t\tauto l = new NODE_LIST(&list_dummy, true);",
			"\t\t\tl->node = new_node;",
			"\t\t\tnew_node->index = l;",
			"\t\t\tnew_node->red = old_node->red;",
			"\t\t\tnew_node->left_size = old_node->left_size;",
			"\t\t\tnew_node->right_size = old_node->right_size;",
			"\t\t\tif (old_node->right) {",
			"\t\t\t\tnew_node->right = f(f, old_node->right, new NODE((T&&) *(old_node->right->key), new_node));",
			"\t\t\t}",
			"\t\t\treturn new_node;",
			"\t\t};",
			"\t\tif (R.node_dummy.left) node_dummy.left = dfs(dfs, R.node_dummy.left, new NODE((T&&) *(R.node_dummy.left->key), &node_dummy));",
			"\t\treturn *this;",
			"\t}",
			"\tstruct NODE_LIST {",
			"\t\tNODE_LIST* fp;",
			"\t\tNODE_LIST* bp;",
			"\t\tNODE* node;",
			"\t\tbool dummy = false;",
			"\t\tNODE_LIST() : fp(this), bp(this), node(nullptr), dummy(true) {}",
			"\t\tNODE_LIST(NODE_LIST* p, bool is_left) : node(nullptr) {",
			"\t\t\tNODE_LIST* pre = is_left ? p->bp : p;",
			"\t\t\tNODE_LIST* nex = is_left ? p : p->fp;",
			"\t\t\tbp = pre;",
			"\t\t\tfp = nex;",
			"\t\t\tpre->fp = this;",
			"\t\t\tnex->bp = this;",
			"\t\t}",
			"\t\t~NODE_LIST() {",
			"\t\t\tif (!dummy) delete node;",
			"\t\t}",
			"\t\tint get_position() {",
			"\t\t\tint result = -1;",
			"\t\t\tbool is_left = false;",
			"\t\t\tNODE* n = this->node;",
			"\t\t\twhile (true) {",
			"\t\t\t\tif (!is_left) result += n->left_size + 1;",
			"\t\t\t\tif (n->par) is_left = (n->par->left == n);",
			"\t\t\t\telse break;",
			"\t\t\t\tn = n->par;",
			"\t\t\t}",
			"\t\t\treturn result;",
			"\t\t}",
			"\t};",
			"\tvoid remove_list(NODE_LIST* p) {",
			"\t\tp->bp->fp = p->fp;",
			"\t\tp->fp->bp = p->bp;",
			"\t\tdelete p;",
			"\t}",
			"\tstruct NODE {",
			"\t\tT* key;",
			"\t\tNODE_LIST* index;",
			"\t\tNODE* left;",
			"\t\tNODE* right;",
			"\t\tNODE* par;",
			"\t\tbool red = true;",
			"\t\tint left_size;",
			"\t\tint right_size;",
			"\t\tNODE() : key(nullptr), index(nullptr), left(nullptr), right(nullptr), par(nullptr), left_size(0), right_size(0) {}",
			"\t\tNODE(T&& d, NODE* par_) : index(nullptr), left(nullptr) , right(nullptr), par(par_), left_size(0), right_size(0) {",
			"\t\t\tkey = new T(d);",
			"\t\t}",
			"\t\t~NODE() {",
			"\t\t\tdelete key;",
			"\t\t}",
			"\t\tvoid RotateR(NODE*& parent, NODE*& child) {",
			"\t\t\tNODE* P = this;",
			"\t\t\tNODE* R = this->par;",
			"\t\t\tNODE* l = this->left;",
			"\t\t\tNODE* B = l->right;",
			"\t\t\tif (R->left == P) R->left = l;",
			"\t\t\telse R->right = l;",
			"\t\t\tl->par = R;",
			"\t\t\tif (B) B->par = P;",
			"\t\t\tP->left = B;",
			"\t\t\tP->left_size = l->right_size;",
			"\t\t\tl->right_size += P->right_size + 1;",
			"\t\t\tl->right = P;",
			"\t\t\tP->par = l;",
			"\t\t\tparent = R;",
			"\t\t\tchild = l;",
			"\t\t}",
			"\t\tvoid RotateL(NODE*& parent, NODE*& child) {",
			"\t\t\tNODE* P = this;",
			"\t\t\tNODE* R = this->par;",
			"\t\t\tNODE* r = this->right;",
			"\t\t\tNODE* B = r->left;",
			"\t\t\tif (R->left == P) R->left = r;",
			"\t\t\telse R->right = r;",
			"\t\t\tr->par = R;",
			"\t\t\tif (B) B->par = P;",
			"\t\t\tP->right = B;",
			"\t\t\tP->right_size = r->left_size;",
			"\t\t\tr->left_size += P->left_size + 1;",
			"\t\t\tr->left = P;",
			"\t\t\tP->par = r;",
			"\t\t\tparent = R;",
			"\t\t\tchild = r;",
			"\t\t}",
			"\t\tvoid RotateRL(NODE*& parent, NODE*& child) {",
			"\t\t\tthis->right->RotateR(parent, child);",
			"\t\t\tthis->RotateL(parent, child);",
			"\t\t}",
			"\t\tvoid RotateLR(NODE*& parent, NODE*& child) {",
			"\t\t\tthis->left->RotateL(parent, child);",
			"\t\t\tthis->RotateR(parent, child);",
			"\t\t}",
			"\t};",
			"\tvoid remove_node(NODE* n, bool is_left) {",
			"\t\tif (n->par->left == n) n->par->left = is_left ? n->left : n->right;",
			"\t\telse  n->par->right = is_left ? n->left : n->right;",
			"\t\tif (is_left) n->left->par = n->par;",
			"\t\telse n->right->par = n->par;",
			"\t\tremove_list(n->index);",
			"\t}",
			"\tvoid remove_node(NODE* n) {",
			"\t\tif (n->par->left == n) n->par->left = nullptr;",
			"\t\telse  n->par->right = nullptr;",
			"\t\tremove_list(n->index);",
			"\t}",
			"\tvoid insert_run(T&& v, NODE* parent, NODE* child, bool is_left) {",
			"\t\tif (is_left) parent->left = child;",
			"\t\telse parent->right = child;",
			"\t\tchild->index = new NODE_LIST(parent->index, is_left);",
			"\t\tchild->index->node = child;",
			"\t\twhile (parent->red) {",
			"\t\t\tif (parent == &node_dummy) {",
			"\t\t\t\tchild->red = false;",
			"\t\t\t\tbreak;",
			"\t\t\t}",
			"\t\t\tNODE* grand = parent->par;",
			"\t\t\tif (child == parent->left && parent == grand->left) {",
			"\t\t\t\tgrand->RotateR(parent, child);",
			"\t\t\t\tchild->left->red = false;",
			"\t\t\t} else if (child == parent->right && parent == grand->left) {",
			"\t\t\t\tgrand->RotateLR(parent, child);",
			"\t\t\t\tchild->left->red = false;",
			"\t\t\t} else if (child == parent->left && parent == grand->right) {",
			"\t\t\t\tgrand->RotateRL(parent, child);",
			"\t\t\t\tchild->right->red = false;",
			"\t\t\t} else if (child == parent->right && parent == grand->right) {",
			"\t\t\t\tgrand->RotateL(parent, child);",
			"\t\t\t\tchild->right->red = false;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\titerator insert(T&& v) {",
			"\t\tNODE* pre = &node_dummy;",
			"\t\tNODE* now = pre->left;",
			"\t\tbool is_left = true;",
			"\t\tpre->left_size++;",
			"\t\twhile (now != nullptr) {",
			"\t\t\tpre = now;",
			"\t\t\tif (Compare()(*(now->key) , v)) now = now->right, is_left = false, pre->right_size++;",
			"\t\t\telse now = now->left, is_left = true, pre->left_size++;",
			"\t\t}",
			"\t\tNODE* child = new NODE((T&&) v, pre);",
			"\t\tinsert_run((T&&) v, pre, child , is_left);",
			"\t\treturn iterator(child->index);",
			"\t}",
			"\titerator insert(const T& v) {",
			"\t\treturn insert((T&&) v);",
			"\t}",
			"\tvoid erase_run(NODE* target) {",
			"\t\tif (target->red) {",
			"\t\t\tif (target->left) remove_node(target, true);",
			"\t\t\telse if (target->right) remove_node(target, false);",
			"\t\t\telse remove_node(target);",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tNODE* child = target->left ? target->left : target->right;",
			"\t\tNODE* parent;",
			"\t\tbool is_left = target->left == child;",
			"\t\tif (child == nullptr) {",
			"\t\t\tparent = target->par;",
			"\t\t\tis_left = (parent->left == target);",
			"\t\t\tremove_node(target);",
			"\t\t} else if (child->red) {",
			"\t\t\tremove_node(target, is_left);",
			"\t\t\tchild->red = false;",
			"\t\t\treturn;",
			"\t\t} else {",
			"\t\t\tremove_node(target, is_left);",
			"\t\t\tparent = child->par;",
			"\t\t\tis_left = (parent->left == child);",
			"\t\t}",
			"\t\twhile (true) {",
			"\t\t\tNODE *t, *u;",
			"\t\t\tif (parent == &node_dummy) {",
			"\t\t\t\tif (parent->left) parent->left->red = false;",
			"\t\t\t\tbreak;",
			"\t\t\t}",
			"\t\t\tif (is_left) {",
			"\t\t\t\tif (!(parent->right->red)) {",
			"\t\t\t\t\tif (parent->right->left && parent->right->left->red) {",
			"\t\t\t\t\t\tparent->RotateRL(t, u);",
			"\t\t\t\t\t\tparent->par->red = parent->red;",
			"\t\t\t\t\t\tparent->red = false;",
			"\t\t\t\t\t\tbreak;",
			"\t\t\t\t\t} else if (parent->right->right && parent->right->right->red) {",
			"\t\t\t\t\t\tparent->RotateL(t, u);",
			"\t\t\t\t\t\tparent->par->red = parent->red;",
			"\t\t\t\t\t\tparent->red = false;",
			"\t\t\t\t\t\tparent->par->right->red = false;",
			"\t\t\t\t\t\tbreak;",
			"\t\t\t\t\t} else {",
			"\t\t\t\t\t\tparent->right->red = true;",
			"\t\t\t\t\t\tif (parent->red) {",
			"\t\t\t\t\t\t\tparent->red = false;",
			"\t\t\t\t\t\t\tbreak;",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t\tis_left = (parent->par->left == parent);",
			"\t\t\t\t\t\tparent = parent->par;",
			"\t\t\t\t\t}",
			"\t\t\t\t} else {",
			"\t\t\t\t\tparent->RotateL(t, u);",
			"\t\t\t\t\tparent->red = true;",
			"\t\t\t\t\tparent->par->red = false;",
			"\t\t\t\t}",
			"\t\t\t} else /* !is_left */{",
			"\t\t\t\tif (!(parent->left->red)) {",
			"\t\t\t\t\tif (parent->left->right && parent->left->right->red) {",
			"\t\t\t\t\t\tparent->RotateLR(t, u);",
			"\t\t\t\t\t\tparent->par->red = parent->red;",
			"\t\t\t\t\t\tparent->red = false;",
			"\t\t\t\t\t\tbreak;",
			"\t\t\t\t\t} else if (parent->left->left && parent->left->left->red) {",
			"\t\t\t\t\t\tparent->RotateR(t, u);",
			"\t\t\t\t\t\tparent->par->red = parent->red;",
			"\t\t\t\t\t\tparent->red = false;",
			"\t\t\t\t\t\tparent->par->left->red = false;",
			"\t\t\t\t\t\tbreak;",
			"\t\t\t\t\t} else {",
			"\t\t\t\t\t\tparent->left->red = true;",
			"\t\t\t\t\t\tif (parent->red) {",
			"\t\t\t\t\t\t\tparent->red = false;",
			"\t\t\t\t\t\t\tbreak;",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t\tis_left = (parent->par->left == parent);",
			"\t\t\t\t\t\tparent = parent->par;",
			"\t\t\t\t\t}",
			"\t\t\t\t} else {",
			"\t\t\t\t\tparent->RotateR(t, u);",
			"\t\t\t\t\tparent->red = true;",
			"\t\t\t\t\tparent->par->red = false;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t} /* while true */",
			"\t}",
			"\titerator erase(T&& v) {",
			"\t\tNODE* pre = &node_dummy;",
			"\t\tNODE* now = pre->left;",
			"\t\tqueue<pair<bool, NODE*>> q;",
			"\t\tq.emplace(true, pre);",
			"\t\tNODE* target = nullptr;",
			"\t\twhile (now != nullptr) {",
			"\t\t\tpre = now;",
			"\t\t\tif (Compare()(*(now->key) , v)) now = now->right, q.emplace(false, pre);",
			"\t\t\telse if (Compare()(v, *(now->key))) now = now->left, q.emplace(true, pre);",
			"\t\t\telse break;",
			"\t\t}",
			"\t\tif (now == nullptr) return iterator(&list_dummy);",
			"\t\ttarget = now;",
			"\t\twhile (!q.empty()) {",
			"\t\t\tif (q.front().first) q.front().second->left_size--;",
			"\t\t\telse q.front().second->right_size--;",
			"\t\t\tq.pop();",
			"\t\t}",
			"\t\tif (target->left != nullptr) {",
			"\t\t\ttarget->left_size--;",
			"\t\t\ttarget = target->left;",
			"\t\t\twhile (target->right) target->right_size--, target = target->right;",
			"\t\t}",
			"\t\tswap(now->key, target->key);",
			"\t\tNODE* t = target->index->fp->node;",
			"\t\terase_run(target);",
			"\t\treturn iterator(t->index);",
			"\t}",
			"\titerator erase(const T& v) {",
			"\t\treturn erase((T&&) v);",
			"\t}",
			"\tint count(T&& v) {",
			"\t\tenum STATUS {LEFT, RIGHT, NEUTRAL};",
			"\t\tint sum = 0;",
			"\t\tqueue<pair<STATUS, NODE*>> q;",
			"\t\tq.emplace(NEUTRAL, node_dummy.left);",
			"\t\twhile (!q.empty()) {",
			"\t\t\tpair<STATUS, NODE*> t = q.front();",
			"\t\t\tq.pop();",
			"\t\t\tint status = t.first;",
			"\t\t\tNODE* n = t.second;",
			"\t\t\tif (n == nullptr) continue;",
			"\t\t\tif (status == NEUTRAL) {",
			"\t\t\t\tif (Compare()(v, *(n->key))) q.emplace(NEUTRAL, n->left);",
			"\t\t\t\telse if (Compare()(*(n->key), v)) q.emplace(NEUTRAL, n->right);",
			"\t\t\t\telse {",
			"\t\t\t\t\tsum++;",
			"\t\t\t\t\tq.emplace(LEFT, n->left);",
			"\t\t\t\t\tq.emplace(RIGHT, n->right);",
			"\t\t\t\t}",
			"\t\t\t} else if (status == LEFT) {",
			"\t\t\t\tif (Compare()(*(n->key), v)) q.emplace(LEFT, n->right);",
			"\t\t\t\telse {",
			"\t\t\t\t\tsum += n->right_size + 1;",
			"\t\t\t\t\tq.emplace(LEFT, n->left);",
			"\t\t\t\t}",
			"\t\t\t} else /* if (status == RIGHT) */{",
			"\t\t\t\tif (Compare()(v, *(n->key))) q.emplace(RIGHT, n->left);",
			"\t\t\t\telse {",
			"\t\t\t\t\tsum += n->left_size + 1;",
			"\t\t\t\t\tq.emplace(RIGHT, n->right);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn sum;",
			"\t}",
			"\tint count(const T& v) {",
			"\t\treturn count((T&&) v);",
			"\t}",
			"\tbool is_balanced() {",
			"\t\tauto dfs = [&](auto f, NODE* R, int& black, int& cnt, bool is_red = true) {",
			"\t\t\tif (is_red && R->red) return false;",
			"\t\t\tint r_black = 0;",
			"\t\t\tint l_black = 0;",
			"\t\t\tint r_cnt = 0;",
			"\t\t\tint l_cnt = 0;",
			"\t\t\tcnt = 1;",
			"\t\t\tif (R->left) {",
			"\t\t\t\tif (!f(f, R->left, l_black, l_cnt, R->red)) return false;",
			"\t\t\t}",
			"\t\t\tif (R->right) {",
			"\t\t\t\tif (!f(f, R->right, r_black, r_cnt, R->red)) return false;",
			"\t\t\t}",
			"\t\t\tif (r_black != l_black) {",
			"\t\t\t\tcerr << \"black\" << endl;",
			"\t\t\t\treturn false;",
			"\t\t\t}",
			"\t\t\tif (r_cnt != R->right_size) {",
			"\t\t\t\tcerr << \"r_cnt\" << endl;",
			"\t\t\t\treturn false;",
			"\t\t\t}",
			"\t\t\tif (l_cnt != R->left_size) {",
			"\t\t\t\tcerr << \"l_cnt\" << endl;",
			"\t\t\t\treturn false;",
			"\t\t\t}",
			"\t\t\tblack = r_black + !(R->red);",
			"\t\t\tcnt += r_cnt + l_cnt;",
			"\t\t\treturn true;",
			"\t\t};",
			"\t\tint t, u;",
			"\t\treturn dfs(dfs, node_dummy.left, t, u);",
			"\t}",
			"\tconst T& operator[](int x) {",
			"\t\tif (x < 0 || size() <= x) throw out_of_range(\"Error at RedBlackSet::operator[]\");",
			"\t\tint pos = 0;",
			"\t\tNODE* now = node_dummy.left;",
			"\t\twhile (true) {",
			"\t\t\tif (pos + now->left_size < x) pos += now->left_size + 1, now = now->right;",
			"\t\t\telse if (x < pos + now->left_size) now = now->left;",
			"\t\t\telse break;",
			"\t\t}",
			"\t\treturn *(now->key);",
			"\t}",
			"};",
			"template<class T>",
			"class RedBlackSetIterator {",
			"\tfriend RedBlackSet<T>;",
			"\tusing NODE_LIST = typename RedBlackSet<T>::NODE_LIST;",
			"\tNODE_LIST* list_ptr;",
			"\tRedBlackSetIterator(NODE_LIST* n) : list_ptr(n) {}",
			"public:",
			"\tRedBlackSetIterator(const RedBlackSetIterator& R) : list_ptr(R.list_ptr) {}",
			"\tRedBlackSetIterator& operator++() {",
			"\t\tif (list_ptr->dummy) throw out_of_range(\"Error at RedBlackSetIterator& operator++()\");",
			"\t\tlist_ptr = list_ptr->fp;",
			"\t\treturn *this;",
			"\t}",
			"\tRedBlackSetIterator operator++(int unused) {",
			"\t\tif (list_ptr->dummy) throw out_of_range(\"Error at RedBlackSetIterator operator++(int)\");",
			"\t\tRedBlackSetIterator result = *this;",
			"\t\tlist_ptr = list_ptr->fp;",
			"\t\treturn result;",
			"\t}",
			"\tRedBlackSetIterator& operator--() {",
			"\t\tif (list_ptr->bp->dummy) throw out_of_range(\"Error at RedBlackSetIterator& operator--()\");",
			"\t\tlist_ptr = list_ptr->bp;",
			"\t\treturn *this;",
			"\t}",
			"\tRedBlackSetIterator operator--(int unused) {",
			"\t\tif (list_ptr->bp->dummy) throw out_of_range(\"Error at RedBlackSetIterator operator--(int)\");",
			"\t\tRedBlackSetIterator result = *this;",
			"\t\tlist_ptr = list_ptr->bp;",
			"\t\treturn result;",
			"\t}",
			"\tint operator-(const RedBlackSetIterator& R) {",
			"\t\treturn list_ptr->get_position() - R.list_ptr->get_position();",
			"\t}",
			"\tconst T& operator*() const {",
			"\t\tassert(list_ptr->node->key);",
			"\t\treturn *(list_ptr->node->key);",
			"\t}",
			"\tbool operator==(const RedBlackSetIterator& R) {",
			"\t\treturn this->list_ptr == R.list_ptr;",
			"\t}",
			"\tbool operator!=(const RedBlackSetIterator& R) {",
			"\t\treturn !(*this == R);",
			"\t}",
			"};",
			"}",
			"",
			"using namespace spihill;",
			"",
			"void check_insert(const int);",
			"void check_erase(const int);",
			"bool check(RedBlackSet<int>& R, multiset<int>& S);",
			"",
			"int main()",
			"{",
			"\tcout << \"START INSERT TEST\" << endl;",
			"\tcheck_insert(100000);",
			"\tcout << \"PASSED\" << endl;",
			"\tcout << \"START ERASE TEST\" << endl;",
			"\tcheck_erase(100000);",
			"\tcout << \"PASSED\" << endl;",
			"\treturn 0;",
			"}",
			"",
			"void check_erase(const int MAX)",
			"{",
			"\tRedBlackSet<int> R_random_small;",
			"\tRedBlackSet<int> R_increase;",
			"\tRedBlackSet<int> R_decrease;",
			"\tRedBlackSet<int> R_nothing;",
			"",
			"\tmultiset<int> S_random_small;",
			"\tmultiset<int> S_increase;",
			"\tmultiset<int> S_decrease;",
			"\tmultiset<int> S_nothing;",
			"",
			"\tstd::random_device seed_gen;",
			"\tstd::mt19937 engine(seed_gen());",
			"",
			"\tstd::uniform_real_distribution<> dist1(-1.0, 1.0);",
			"",
			"\tfor (int i = -MAX; i < MAX; i++) {",
			"\t\tint big = 1000000000 * dist1(engine);",
			"\t\tint small = 100 * dist1(engine);",
			"\t\tR_random_small.insert(small);",
			"\t\tR_increase.insert(i);",
			"\t\tR_decrease.insert(i);",
			"\t\tR_nothing.insert(big);",
			"\t\tS_random_small.insert(small);",
			"\t\tS_increase.insert(i);",
			"\t\tS_decrease.insert(i);",
			"\t}",
			"\tfor (int i = 0; i < MAX; i++) {",
			"\t\tR_increase.erase(-i - 1);",
			"\t\tR_decrease.erase(i);",
			"\t\tS_increase.erase(-i - 1);",
			"\t\tS_decrease.erase(i);",
			"\t}",
			"",
			"\tfor (int i = -100; i <= 100; i++) {",
			"\t\tassert(R_random_small.count(i) == (int) S_random_small.count(i));",
			"\t\tassert((int) S_random_small.count(i) == R_random_small.upper_bound(i) - R_random_small.lower_bound(i));",
			"\t}",
			"",
			"\tfor (int i = 0; i < 10; i++) {",
			"\t\tint small = 100 * dist1(engine);",
			"\t\twhile (R_random_small.erase(small) != R_random_small.end());",
			"\t\tS_random_small.erase(small);",
			"\t}",
			"",
			"\tfor (int i = -100; i <= 100; i++) {",
			"\t\tassert(R_random_small.count(i) == (int) S_random_small.count(i));",
			"\t\tassert((int) S_random_small.count(i) == R_random_small.upper_bound(i) - R_random_small.lower_bound(i));",
			"\t}",
			"",
			"\twhile (R_nothing.erase(*(R_nothing.begin())) != R_nothing.end());",
			"",
			"\tassert(check(R_increase, S_increase));",
			"\tassert(check(R_decrease, S_decrease));",
			"\tassert(check(R_random_small, S_random_small));",
			"\tassert(check(R_nothing, S_nothing));",
			"\tassert(R_increase.is_balanced());",
			"\tassert(R_decrease.is_balanced());",
			"\tassert(R_random_small.is_balanced());",
			"\treturn;",
			"}",
			"",
			"void check_insert(const int MAX)",
			"{",
			"\tRedBlackSet<int> R_random_big;",
			"\tRedBlackSet<int> R_random_small;",
			"\tRedBlackSet<int> R_increase;",
			"\tRedBlackSet<int> R_decrease;",
			"",
			"\tmultiset<int> S_random_big;",
			"\tmultiset<int> S_random_small;",
			"\tmultiset<int> S_increase;",
			"\tmultiset<int> S_decrease;",
			"",
			"\tstd::random_device seed_gen;",
			"\tstd::mt19937 engine(seed_gen());",
			"",
			"\tstd::uniform_real_distribution<> dist1(-1.0, 1.0);",
			"",
			"\tfor (int i = -MAX; i < MAX; i++) {",
			"\t\tint big = 1000000000 * dist1(engine);",
			"\t\tint small = 100 * dist1(engine);",
			"\t\tR_random_big.insert(big);",
			"\t\tR_random_small.insert(small);",
			"\t\tR_increase.insert(i);",
			"\t\tR_decrease.insert(-i);",
			"\t\tS_random_big.insert(big);",
			"\t\tS_random_small.insert(small);",
			"\t\tS_increase.insert(i);",
			"\t\tS_decrease.insert(-i);",
			"\t}",
			"\tauto R_copy(R_random_big);",
			"\tauto S_copy = S_random_big;",
			"\tRedBlackSet<int> R_assign;",
			"\tR_assign = R_random_big;",
			"\tfor (int i = -MAX; i < MAX; i++) {",
			"\t\tint big = 1000000000 * dist1(engine);",
			"\t\tR_copy.insert(big);",
			"\t\tR_assign.insert(big);",
			"\t\tS_copy.insert(big);",
			"\t}",
			"\tassert(check(R_increase, S_increase));",
			"\tassert(check(R_decrease, S_decrease));",
			"\tassert(check(R_random_big, S_random_big));",
			"\tassert(check(R_random_small, S_random_small));",
			"\tassert(check(R_copy, S_copy));",
			"\tassert(check(R_assign, S_copy));",
			"\tassert(R_increase.is_balanced());",
			"\tassert(R_decrease.is_balanced());",
			"\tassert(R_random_big.is_balanced());",
			"\tassert(R_copy.is_balanced());",
			"\tassert(R_assign.is_balanced());",
			"\tassert(R_random_small.is_balanced());",
			"\treturn;",
			"}",
			"",
			"bool check(RedBlackSet<int>& R, multiset<int>& S)",
			"{",
			"\tauto itr_S = S.begin();",
			"\tauto itr_R = R.begin();",
			"\tif ((int) S.size() != R.size()) {",
			"\t\tcerr << \"S.size() != R.size()\" << endl;",
			"\t\treturn false;",
			"\t}",
			"\tfor (; itr_R != R.end(); itr_R++, itr_S++) {",
			"\t\tif (*itr_R != *itr_S) return false;",
			"\t}",
			"\treturn itr_S == S.end();",
			"}"
		]
	},
	"RMQ_RAQ": {
		"prefix": "RMQ_RAQ",
		"body": [
			"/*",
			"\tUNITY_NODE min\u306e\u5358\u4f4d\u5143",
			"\tUNITY_LAZY add\u306e\u5358\u4f4d\u5143",
			"\tnode\u306e\u521d\u671f\u5024\u306b\u6ce8\u610f(init)",
			"*/",
			"template <class NODE, class LAZY, NODE UNITY_NODE, LAZY UNITY_LAZY>",
			"struct LazySegTree {",
			"// edit start",
			"\tvoid add(LAZY &a, LAZY b) {",
			"\t\ta += b;",
			"\t}",
			"\tvoid reflect(NODE& a, LAZY b, int l, int r) {",
			"\t\ta += b;",
			"\t}",
			"\tNODE merge(NODE a, NODE b) {",
			"\t\treturn min(a, b);",
			"\t}",
			"// end",
			"\tint n;",
			"\tvector<NODE> node;",
			"\tvector<LAZY> lazy;",
			"\tLazySegTree(int sz) {",
			"\t\tinit(sz);",
			"\t}",
			"\tvoid init(int sz) {",
			"\t\tn = 1;",
			"\t\twhile (n < sz) n *= 2;",
			"\t\tnode.assign(2*n-1, 0);",
			"\t\tlazy.assign(2*n-1, UNITY_LAZY);",
			"\t}",
			"\tvoid eval(int l, int r, int k) {",
			"\t\treflect(node[k], lazy[k], l, r);",
			"\t\tif (r - l > 1) {",
			"\t\t\tadd(lazy[k*2+1], lazy[k]);",
			"\t\t\tadd(lazy[k*2+2], lazy[k]);",
			"\t\t}",
			"\t\tlazy[k] = UNITY_LAZY;",
			"\t}",
			"\tvoid renode(int k) {",
			"\t\tnode[k] = merge(node[k*2+1], node[k*2+2]);",
			"\t}",
			"\tvoid set(int a, int b, LAZY x, int k=0, int l=0, int r=-1) {",
			"\t\tif (r < 0) r = n;",
			"\t\tif (b <= l || r <= a) {",
			"\t\t\teval(l, r, k);",
			"\t\t} else if (a <= l && r <= b) {",
			"\t\t\tadd(lazy[k], x);",
			"\t\t\teval(l, r, k);",
			"\t\t} else {",
			"\t\t\teval(l, r, k);",
			"\t\t\tset(a, b, x, k*2+1, l, (l+r) / 2);",
			"\t\t\tset(a, b, x, k*2+2, (l+r) / 2, r);",
			"\t\t\trenode(k);",
			"\t\t}",
			"\t}",
			"\tNODE get(int a, int b, int k=0, int l=0, int r=-1) {",
			"\t\tif (r < 0) r = n;",
			"\t\teval(l, r, k);",
			"\t\tif (b <= l || r <= a) {",
			"\t\t\treturn UNITY_NODE;",
			"\t\t} else if (a <= l && r <= b) {",
			"\t\t\treturn node[k];",
			"\t\t} else {",
			"\t\t\tNODE t1 = get(a, b, 2*k+1, l, (l+r) / 2);",
			"\t\t\tNODE t2 = get(a, b, 2*k+2, (l+r) / 2, r);",
			"\t\t\trenode(k);",
			"\t\t\treturn merge(t1, t2);",
			"\t\t}",
			"\t}",
			"};"
		]
	},
	"RMQ_RUQ": {
		"prefix": "RMQ_RUQ",
		"body": [
			"/*",
			"\tUNITY_NODE min\u306e\u5358\u4f4d\u5143",
			"\tUNITY_LAZY update\u306e\u5358\u4f4d\u5143",
			"\tnode\u306e\u521d\u671f\u5024\u306b\u6ce8\u610f(init)",
			"*/",
			"template <class NODE, class LAZY, NODE UNITY_NODE, LAZY UNITY_LAZY>",
			"struct LazySegTree {",
			"// edit start",
			"\tvoid add(LAZY &a, LAZY b) {",
			"\t\tif (b == UNITY_LAZY) return;",
			"\t\ta = b;",
			"\t}",
			"\tvoid reflect(NODE& a, LAZY b, int l, int r) {",
			"\t\tif (b == UNITY_LAZY) return;",
			"\t\ta = b;",
			"\t}",
			"\tNODE merge(NODE a, NODE b) {",
			"\t\treturn min(a, b);",
			"\t}",
			"// end",
			"\tint n;",
			"\tvector<NODE> node;",
			"\tvector<LAZY> lazy;",
			"\tLazySegTree(int sz) {",
			"\t\tinit(sz);",
			"\t}",
			"\tvoid init(int sz) {",
			"\t\tn = 1;",
			"\t\twhile (n < sz) n *= 2;",
			"\t\tnode.assign(2*n-1, UNITY_NODE);",
			"\t\tlazy.assign(2*n-1, UNITY_LAZY);",
			"\t}",
			"\tvoid eval(int l, int r, int k) {",
			"\t\treflect(node[k], lazy[k], l, r);",
			"\t\tif (r - l > 1) {",
			"\t\t\tadd(lazy[k*2+1], lazy[k]);",
			"\t\t\tadd(lazy[k*2+2], lazy[k]);",
			"\t\t}",
			"\t\tlazy[k] = UNITY_LAZY;",
			"\t}",
			"\tvoid renode(int k) {",
			"\t\tnode[k] = merge(node[k*2+1], node[k*2+2]);",
			"\t}",
			"\tvoid set(int a, int b, LAZY x, int k=0, int l=0, int r=-1) {",
			"\t\tif (r < 0) r = n;",
			"\t\tif (b <= l || r <= a) {",
			"\t\t\teval(l, r, k);",
			"\t\t} else if (a <= l && r <= b) {",
			"\t\t\tadd(lazy[k], x);",
			"\t\t\teval(l, r, k);",
			"\t\t} else {",
			"\t\t\teval(l, r, k);",
			"\t\t\tset(a, b, x, k*2+1, l, (l+r) / 2);",
			"\t\t\tset(a, b, x, k*2+2, (l+r) / 2, r);",
			"\t\t\trenode(k);",
			"\t\t}",
			"\t}",
			"\tNODE get(int a, int b, int k=0, int l=0, int r=-1) {",
			"\t\tif (r < 0) r = n;",
			"\t\teval(l, r, k);",
			"\t\tif (b <= l || r <= a) {",
			"\t\t\treturn UNITY_NODE;",
			"\t\t} else if (a <= l && r <= b) {",
			"\t\t\treturn node[k];",
			"\t\t} else {",
			"\t\t\tNODE t1 = get(a, b, 2*k+1, l, (l+r) / 2);",
			"\t\t\tNODE t2 = get(a, b, 2*k+2, (l+r) / 2, r);",
			"\t\t\trenode(k);",
			"\t\t\treturn merge(t1, t2);",
			"\t\t}",
			"\t}",
			"};"
		]
	},
	"RSQ_RAQ": {
		"prefix": "RSQ_RAQ",
		"body": [
			"/*",
			"\tUNITY_NODE sum\u306e\u5358\u4f4d\u5143",
			"\tUNITY_LAZY add\u306e\u5358\u4f4d\u5143",
			"\tnode\u306e\u521d\u671f\u5024\u306b\u6ce8\u610f(init)",
			"\tadd\u306e\u547c\u3073\u51fa\u3057\u5143\u306b\u6ce8\u610f(\u533a\u9593\u306e\u9577\u3055\u306b\u6bd4\u4f8b\u3059\u308b)",
			"*/",
			"template <class NODE, class LAZY, NODE UNITY_NODE, LAZY UNITY_LAZY>",
			"struct LazySegTree {",
			"// edit start",
			"\tvoid add(LAZY &a, LAZY b) {",
			"\t\ta += b;",
			"\t}",
			"\tvoid reflect(NODE& a, LAZY b, int l, int r) {",
			"\t\ta += b;",
			"\t}",
			"\tNODE merge(NODE a, NODE b) {",
			"\t\treturn a + b;",
			"\t}",
			"// end",
			"\tint n;",
			"\tvector<NODE> node;",
			"\tvector<LAZY> lazy;",
			"\tLazySegTree(int sz) {",
			"\t\tinit(sz);",
			"\t}",
			"\tvoid init(int sz) {",
			"\t\tn = 1;",
			"\t\twhile (n < sz) n *= 2;",
			"\t\tnode.assign(2*n-1, 0);",
			"\t\tlazy.assign(2*n-1, UNITY_LAZY);",
			"\t}",
			"\tvoid eval(int l, int r, int k) {",
			"\t\treflect(node[k], lazy[k], l, r);",
			"\t\tif (r - l > 1) {",
			"\t\t\tadd(lazy[k*2+1], lazy[k] / 2);",
			"\t\t\tadd(lazy[k*2+2], lazy[k] / 2);",
			"\t\t}",
			"\t\tlazy[k] = UNITY_LAZY;",
			"\t}",
			"\tvoid renode(int k) {",
			"\t\tnode[k] = merge(node[k*2+1], node[k*2+2]);",
			"\t}",
			"\tvoid set(int a, int b, LAZY x, int k=0, int l=0, int r=-1) {",
			"\t\tif (r < 0) r = n;",
			"\t\tif (b <= l || r <= a) {",
			"\t\t\teval(l, r, k);",
			"\t\t} else if (a <= l && r <= b) {",
			"\t\t\tadd(lazy[k], x * (r - l));",
			"\t\t\teval(l, r, k);",
			"\t\t} else {",
			"\t\t\teval(l, r, k);",
			"\t\t\tset(a, b, x, k*2+1, l, (l+r) / 2);",
			"\t\t\tset(a, b, x, k*2+2, (l+r) / 2, r);",
			"\t\t\trenode(k);",
			"\t\t}",
			"\t}",
			"\tNODE get(int a, int b, int k=0, int l=0, int r=-1) {",
			"\t\tif (r < 0) r = n;",
			"\t\teval(l, r, k);",
			"\t\tif (b <= l || r <= a) {",
			"\t\t\treturn UNITY_NODE;",
			"\t\t} else if (a <= l && r <= b) {",
			"\t\t\treturn node[k];",
			"\t\t} else {",
			"\t\t\tNODE t1 = get(a, b, 2*k+1, l, (l+r) / 2);",
			"\t\t\tNODE t2 = get(a, b, 2*k+2, (l+r) / 2, r);",
			"\t\t\trenode(k);",
			"\t\t\treturn merge(t1, t2);",
			"\t\t}",
			"\t}",
			"};"
		]
	},
	"RSQ_RUQ": {
		"prefix": "RSQ_RUQ",
		"body": [
			"/*",
			"\tUNITY_NODE sum\u306e\u5358\u4f4d\u5143",
			"\tUNITY_LAZY update\u306e\u5358\u4f4d\u5143",
			"\tnode\u306e\u521d\u671f\u5024\u306b\u6ce8\u610f(init)",
			"\tadd\u306e\u547c\u3073\u51fa\u3057\u5143\u306b\u6ce8\u610f(\u533a\u9593\u306e\u9577\u3055\u306b\u6bd4\u4f8b\u3059\u308b)",
			"\t\u4e0a\u306e\u95a2\u4fc2\u3067UNITY_LAZY / 2\u3082\u5358\u4f4d\u5143\u3068\u307f\u306a\u3057\u3066\u3044\u308b",
			"*/",
			"template <class NODE, class LAZY, NODE UNITY_NODE, LAZY UNITY_LAZY>",
			"struct LazySegTree {",
			"// edit start",
			"\tvoid add(LAZY &a, LAZY b) {",
			"\t\tif (b == UNITY_LAZY || b == UNITY_LAZY / 2) return;",
			"\t\ta = b;",
			"\t}",
			"\tvoid reflect(NODE& a, LAZY b, int l, int r) {",
			"\t\tif (b == UNITY_LAZY || b == UNITY_LAZY / 2) return;",
			"\t\ta = b;",
			"\t}",
			"\tNODE merge(NODE a, NODE b) {",
			"\t\treturn a + b;",
			"\t}",
			"// end",
			"\tint n;",
			"\tvector<NODE> node;",
			"\tvector<LAZY> lazy;",
			"\tLazySegTree(int sz) {",
			"\t\tinit(sz);",
			"\t}",
			"\tvoid init(int sz) {",
			"\t\tn = 1;",
			"\t\twhile (n < sz) n *= 2;",
			"\t\tnode.assign(2*n-1, 0);",
			"\t\tlazy.assign(2*n-1, UNITY_LAZY);",
			"\t}",
			"\tvoid eval(int l, int r, int k) {",
			"\t\treflect(node[k], lazy[k], l, r);",
			"\t\tif (r - l > 1) {",
			"\t\t\tadd(lazy[k*2+1], lazy[k] / 2);",
			"\t\t\tadd(lazy[k*2+2], lazy[k] / 2);",
			"\t\t}",
			"\t\tlazy[k] = UNITY_LAZY;",
			"\t}",
			"\tvoid renode(int k) {",
			"\t\tnode[k] = merge(node[k*2+1], node[k*2+2]);",
			"\t}",
			"\tvoid set(int a, int b, LAZY x, int k=0, int l=0, int r=-1) {",
			"\t\tif (r < 0) r = n;",
			"\t\tif (b <= l || r <= a) {",
			"\t\t\teval(l, r, k);",
			"\t\t} else if (a <= l && r <= b) {",
			"\t\t\tadd(lazy[k], x * (r - l));",
			"\t\t\teval(l, r, k);",
			"\t\t} else {",
			"\t\t\teval(l, r, k);",
			"\t\t\tset(a, b, x, k*2+1, l, (l+r) / 2);",
			"\t\t\tset(a, b, x, k*2+2, (l+r) / 2, r);",
			"\t\t\trenode(k);",
			"\t\t}",
			"\t}",
			"\tNODE get(int a, int b, int k=0, int l=0, int r=-1) {",
			"\t\tif (r < 0) r = n;",
			"\t\teval(l, r, k);",
			"\t\tif (b <= l || r <= a) {",
			"\t\t\treturn UNITY_NODE;",
			"\t\t} else if (a <= l && r <= b) {",
			"\t\t\treturn node[k];",
			"\t\t} else {",
			"\t\t\tNODE t1 = get(a, b, 2*k+1, l, (l+r) / 2);",
			"\t\t\tNODE t2 = get(a, b, 2*k+2, (l+r) / 2, r);",
			"\t\t\trenode(k);",
			"\t\t\treturn merge(t1, t2);",
			"\t\t}",
			"\t}",
			"};"
		]
	},
	"Union_Find": {
		"prefix": "Union_Find",
		"body": [
			"struct Union_Find",
			"{",
			"\tvector<int> par;",
			"\tint n;",
			"\tUnion_Find(int a) {init(a);}",
			"\tvoid init(int a) {",
			"\t\tn = a;",
			"\t\tpar.resize(n, -1);",
			"\t}",
			"\tint root(int x) {",
			"\t\treturn par[x] < 0 ? x : par[x] = root(par[x]);",
			"\t}",
			"\tbool same(int x, int y) {",
			"\t\treturn root(x) == root(y);",
			"\t}",
			"\tbool unite(int x, int y) {",
			"\t\tx = root(x);",
			"\t\ty = root(y);",
			"\t\tif (x == y) return false;",
			"\t\tif (size(x) < size(y)) swap(x, y);",
			"\t\tpar[x] += par[y];",
			"\t\tpar[y] = x;",
			"\t\treturn true;",
			"\t}",
			"\tint size(int x) {",
			"\t\tx = root(x);",
			"\t\treturn -par[x];",
			"\t}",
			"};"
		]
	},
	"Union_Find_Weight": {
		"prefix": "Union_Find_Weight",
		"body": [
			"template<class Abel> struct Union_Find_Weight",
			"{",
			"\tvector<int> par;",
			"\tvector<Abel> diff_weight;",
			"\tint n;",
			"\tUnion_Find_Weight(int a, Abel SUM_UNITY = 0) {init(a, SUM_UNITY);}",
			"\tvoid init(int a, Abel SUM_UNITY) {",
			"\t\tn = a;",
			"\t\tpar.resize(n, -1);",
			"\t\tdiff_weight.resize(n, SUM_UNITY);",
			"\t}",
			"\tint root(int x) {",
			"\t\tif (par[x] < 0) return x;",
			"\t\tint r = root(par[x]);",
			"\t\tdiff_weight[x] += diff_weight[par[x]];",
			"\t\treturn par[x] = r;",
			"\t}",
			"\tAbel weight(int x) {",
			"\t\troot(x);",
			"\t\treturn diff_weight[x];",
			"\t}",
			"\tAbel diff(int x, int y) {",
			"\t\treturn weight(y) - weight(x);",
			"\t}",
			"\tbool same(int x, int y) {",
			"\t\treturn root(x) == root(y);",
			"\t}",
			"// weight(y) - weight(x) = w",
			"\tbool unite(int x, int y, Abel w) {",
			"\t\tw += weight(x);",
			"\t\tw -= weight(y);",
			"\t\tx = root(x);",
			"\t\ty = root(y);",
			"\t\tif (x == y) return false;",
			"\t\tif (size(x) < size(y)) swap(x, y), w = -w;",
			"\t\tpar[x] += par[y];",
			"\t\tpar[y] = x;",
			"\t\tdiff_weight[y] = w;",
			"\t\treturn true;",
			"\t}",
			"\tint size(int x) {",
			"\t\tx = root(x);",
			"\t\treturn -par[x];",
			"\t}",
			"};"
		]
	}
}