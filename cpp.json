{
	"Prim": {
		"prefix": "Prim",
		"body": [
			"template<class T>",
			"struct Graph {",
			"\tstruct Vertex {};",
			"\tstruct Edge {",
			"\t\tint from;",
			"\t\tint to;",
			"\t\tT cost;",
			"\t\tEdge(int t, T c) : to(t), cost(c) {}",
			"\t\tEdge() {}",
			"\t};",
			"\tint sz;",
			"\tvector<Vertex> v;",
			"\tvector<vector<Edge>> e;",
			"\tvector<Edge> edges;",
			"\tGraph(int n) : sz(n), v(n), e(n) {}",
			"\ttemplate<class... Args>",
			"\tinline void assign_vertex(int pos, Args... args) {",
			"\t\tv[pos] = V(args...);",
			"\t}",
			"\t// from, to, cost",
			"\ttemplate<class... Args>",
			"\tinline void add_edge(int pos, Args... args) {",
			"\t\te[pos].emplace_back(args...);",
			"\t}",
			"\tinline int size() {",
			"\t\treturn sz;",
			"\t}",
			"};",
			"",
			"template<class T>",
			"struct Prim : public Graph<T> {",
			"\tPrim(int n) : Graph<T>(n) {};",
			"\tT Prim_solve() {",
			"\t\tT res = 0;",
			"\t\tvector<char> used(this->sz, 0);",
			"\t\tpriority_queue<pair<T, int>, vector<pair<T, int>>, greater<>> q;",
			"\t\tq.emplace(0, 0);",
			"\t\twhile (!q.empty()) {",
			"\t\t\tauto p = q.top(); q.pop();",
			"\t\t\tif (used[p.second] != 0) continue;",
			"\t\t\tused[p.second] = 1;",
			"\t\t\tres += p.first;",
			"\t\t\tfor (auto& x : this->e[p.second]) {",
			"\t\t\t\tq.emplace(x.cost, x.to);",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"};"
		]
	},
	"UnionFind": {
		"prefix": "UnionFind",
		"body": [
			"struct UnionFind",
			"{",
			"\tvector<int> par;",
			"\tint n;",
			"\tUnionFind(int a) {init(a);}",
			"\tvoid init(int a) {",
			"\t\tn = a;",
			"\t\tpar.resize(n, -1);",
			"\t}",
			"\tint root(int x) {",
			"\t\treturn par[x] < 0 ? x : par[x] = root(par[x]);",
			"\t}",
			"\tbool same(int x, int y) {",
			"\t\treturn root(x) == root(y);",
			"\t}",
			"\tbool unite(int x, int y) {",
			"\t\tx = root(x);",
			"\t\ty = root(y);",
			"\t\tif (x == y) return false;",
			"\t\tif (size(x) < size(y)) swap(x, y);",
			"\t\tpar[x] += par[y];",
			"\t\tpar[y] = x;",
			"\t\treturn true;",
			"\t}",
			"\tint size(int x) {",
			"\t\tx = root(x);",
			"\t\treturn -par[x];",
			"\t}",
			"};"
		]
	},
	"RMQ_RAQ": {
		"prefix": "RMQ_RAQ",
		"body": [
			"/*",
			"\tUNITY_NODE min\u306e\u5358\u4f4d\u5143",
			"\tUNITY_LAZY add\u306e\u5358\u4f4d\u5143",
			"\tnode\u306e\u521d\u671f\u5024\u306b\u6ce8\u610f(init)",
			"*/",
			"template <class NODE, class LAZY, NODE UNITY_NODE, LAZY UNITY_LAZY>",
			"struct LazySegTree {",
			"// edit start",
			"\tvoid add(LAZY &a, LAZY b) {",
			"\t\ta += b;",
			"\t}",
			"\tvoid reflect(NODE& a, LAZY b, int l, int r) {",
			"\t\ta += b;",
			"\t}",
			"\tNODE merge(NODE a, NODE b) {",
			"\t\treturn min(a, b);",
			"\t}",
			"// end",
			"\tint n;",
			"\tvector<NODE> node;",
			"\tvector<LAZY> lazy;",
			"\tLazySegTree(int sz) {",
			"\t\tinit(sz);",
			"\t}",
			"\tvoid init(int sz) {",
			"\t\tn = 1;",
			"\t\twhile (n < sz) n *= 2;",
			"\t\tnode.assign(2*n-1, 0);",
			"\t\tlazy.assign(2*n-1, UNITY_LAZY);",
			"\t}",
			"\tvoid eval(int l, int r, int k) {",
			"\t\treflect(node[k], lazy[k], l, r);",
			"\t\tif (r - l > 1) {",
			"\t\t\tadd(lazy[k*2+1], lazy[k]);",
			"\t\t\tadd(lazy[k*2+2], lazy[k]);",
			"\t\t}",
			"\t\tlazy[k] = UNITY_LAZY;",
			"\t}",
			"\tvoid renode(int k) {",
			"\t\tnode[k] = merge(node[k*2+1], node[k*2+2]);",
			"\t}",
			"\tvoid set(int a, int b, LAZY x, int k=0, int l=0, int r=-1) {",
			"\t\tif (r < 0) r = n;",
			"\t\tif (b <= l || r <= a) {",
			"\t\t\teval(l, r, k);",
			"\t\t} else if (a <= l && r <= b) {",
			"\t\t\tadd(lazy[k], x);",
			"\t\t\teval(l, r, k);",
			"\t\t} else {",
			"\t\t\teval(l, r, k);",
			"\t\t\tset(a, b, x, k*2+1, l, (l+r) / 2);",
			"\t\t\tset(a, b, x, k*2+2, (l+r) / 2, r);",
			"\t\t\trenode(k);",
			"\t\t}",
			"\t}",
			"\tNODE get(int a, int b, int k=0, int l=0, int r=-1) {",
			"\t\tif (r < 0) r = n;",
			"\t\teval(l, r, k);",
			"\t\tif (b <= l || r <= a) {",
			"\t\t\treturn UNITY_NODE;",
			"\t\t} else if (a <= l && r <= b) {",
			"\t\t\treturn node[k];",
			"\t\t} else {",
			"\t\t\tNODE t1 = get(a, b, 2*k+1, l, (l+r) / 2);",
			"\t\t\tNODE t2 = get(a, b, 2*k+2, (l+r) / 2, r);",
			"\t\t\trenode(k);",
			"\t\t\treturn merge(t1, t2);",
			"\t\t}",
			"\t}",
			"};"
		]
	},
	"class2": {
		"prefix": "class2",
		"body": [
			"struct $1",
			"{",
			"\t$2 $4;",
			"\t$3 $5;",
			"\t$1($2 v1, $3 v2) : $4(v1), $5(v2) {}",
			"\t$1() {}",
			"\tbool operator<(const $1 r) const {",
			"\t\treturn $4 == r.$4 ? $5 < r.$5 : $4 < r.$4;",
			"\t}",
			"\tbool operator>(const $1 r) const {",
			"\t\treturn r < *this;",
			"\t}",
			"\tbool operator>=(const $1 r) const {",
			"\t\treturn !(*this < r);",
			"\t}",
			"\tbool operator<=(const $1 r) const {",
			"\t\treturn !(r < *this);",
			"\t}",
			"\tbool operator==(const $1 r) const {",
			"\t\treturn !(r < *this) && !(*this < r);",
			"\t}",
			"\tbool operator!=(const $1 r) const {",
			"\t\treturn (r < *this) || (*this < r);",
			"\t}",
			"};"
		]
	},
	"Matrix": {
		"prefix": "Matrix",
		"body": [
			"template <class T>",
			"struct Matrix {",
			"\tint row;",
			"\tint column;",
			"\tvector<vector<T>> v;",
			"\tvector<T> &operator[](int i) { return (v[i]); }",
			"\tMatrix(int i, int j) {init(i, j);}",
			"\tMatrix() : Matrix(0, 0) {}",
			"\tvoid init(int i, int j) {",
			"\t\trow = i;",
			"\t\tcolumn = j;",
			"\t\tv.resize(i, vector<T>(j, 0));",
			"\t}",
			"\tMatrix(const Matrix &cp) {",
			"\t\trow = cp.row;",
			"\t\tcolumn = cp.column;",
			"\t\tv = cp.v;",
			"\t}",
			"\t~Matrix() {}",
			"\tMatrix operator=(const Matrix &a) {",
			"\t\trow = a.row;",
			"\t\tcolumn = a.column;",
			"\t\tv = a.v;",
			"\t\treturn (*this);",
			"\t}",
			"\tMatrix operator+(const Matrix &a) {",
			"\t\tMatrix r(row, column);",
			"\t\tfor (int i = 0; i < row; i++) {",
			"\t\t\tfor (int j = 0; j < column; j++) {",
			"\t\t\t\tr.v[i][j] = v[i][j] + a.v[i][j];",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn (r);",
			"\t}",
			"\tMatrix operator-(const Matrix &a) {",
			"\t\tMatrix r(row, column);",
			"\t\tfor (int i = 0; i < row; i++) {",
			"\t\t\tfor (int j = 0; j < column; j++) {",
			"\t\t\t\tr.v[i][j] = v[i][j] - a.v[i][j];",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn (r);",
			"\t}",
			"\tMatrix operator*(const Matrix &a)",
			"\t{",
			"\t\tMatrix r(row, a.column);",
			"\t\tfor (int i = 0; i < row; i++) {",
			"\t\t\tfor (int j = 0; j < a.column; j++) {",
			"\t\t\t\tfor (int k = 0; k < column; k++) {",
			"\t\t\t\t\tr.v[i][j] += v[i][k] * a.v[k][j];",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn (r);",
			"\t}",
			"\tMatrix operator*(const int b) {",
			"\t\tMatrix r(row, column);",
			"\t\tfor (int i = 0; i < row; i++) {",
			"\t\t\tfor (int j = 0; j < column; j++) {",
			"\t\t\t\tr.v[i][j] = b * v[i][j];",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn (r);",
			"\t}",
			"\tMatrix operator+(const int b) {",
			"\t\tMatrix r(row, column);",
			"\t\tfor (int i = 0; i < row; i++) {",
			"\t\t\tfor (int j = 0; j < column; j++) {",
			"\t\t\t\tr.v[i][j] = b + v[i][j];",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn (r);",
			"\t}",
			"\tMatrix operator-(const int b) {",
			"\t\tMatrix r(row, column);",
			"\t\tfor (int i = 0; i < row; i++) {",
			"\t\t\tfor (int j = 0; j < column; j++) {",
			"\t\t\t\tr.v[i][j] = v[i][j] - b;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn (r);",
			"\t}",
			"\tvoid unit_matrix() {",
			"\t\tint n = row;",
			"\t\tfor (int i = 0; i < n; i++) {",
			"\t\t\tfor (int j = 0; j < n; j++) {",
			"\t\t\t\tv[i][j] = (i == j);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tMatrix<T> accumu_sum() {",
			"\t\tMatrix<T> r(row+1, column+1);",
			"\t\tfor (int i = 1; i <= row; i++) {",
			"\t\t\tfor (int j = 1; j <= column; j++) {",
			"\t\t\t\tr[i][j] = v[i-1][j-1] + r[i-1][j] + r[i][j-1] - r[i-1][j-1];",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn (r);",
			"\t}",
			"\t//\u534a\u958b\u533a\u9593\u3067\u6307\u5b9a",
			"\tT get_sum_accumu(int r1, int c1, int r2, int c2) {",
			"\t\treturn v[r2][c2] + v[r1][c1] - v[r2][c1] - v[r1][c2];",
			"\t}",
			"\tMatrix transposed() {",
			"\t\tMatrix t(column, row);",
			"\t\tfor (int i = 0; i < row; i++) {",
			"\t\t\tfor (int j = 0; j < column; j++) {",
			"\t\t\t\tt[j][i] = v[i][j];",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn (t);",
			"\t}",
			"\tfriend ostream &operator<<(ostream &lhs, const Matrix<T> &rhs) {",
			"\t\tfor (int i = 0; i < rhs.row; i++) {",
			"\t\t\tfor (int j = 0; j < rhs.column - 1; j++) {",
			"\t\t\t\tlhs << rhs.v[i][j] << \" \";",
			"\t\t\t}",
			"\t\t\tlhs << rhs.v[i][rhs.column - 1];",
			"\t\t\tif (i != rhs.row-1) cout << endl;",
			"\t\t}",
			"\t\treturn lhs;",
			"\t}",
			"\tfriend istream &operator>>(istream &lhs, Matrix<T> &rhs) {",
			"\t\tfor (int i = 0; i < rhs.row; i++) {",
			"\t\t\tfor (int j = 0; j < rhs.column; j++) {",
			"\t\t\t\tlhs >> rhs.v[i][j];",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn lhs;",
			"\t}",
			"};"
		]
	},
	"Dijkstra": {
		"prefix": "Dijkstra",
		"body": [
			"template<class T>",
			"struct Graph {",
			"\tstruct Vertex {",
			"\t\tT cost;",
			"\t\tVertex(T v1) : cost(v1) {}",
			"\t\tVertex() {}",
			"\t};",
			"\tstruct Edge {",
			"\t\tint to;",
			"\t\tT cost;",
			"\t\tEdge(int t, T c) : to(t), cost(c) {}",
			"\t\tEdge() {}",
			"\t};",
			"\tint sz;",
			"\tvector<Vertex> v;",
			"\tvector<vector<Edge>> e;",
			"\tGraph(int n) : sz(n), v(n), e(n) {}",
			"\ttemplate<class... Args>",
			"\tinline void assign_vertex(int pos, Args... args) {",
			"\t\tv[pos] = Vertex(args...);",
			"\t}",
			"\ttemplate<class... Args>",
			"\tinline void add_edge(int pos, Args... args) {",
			"\t\te[pos].emplace_back(args...);",
			"\t}",
			"\tinline int size() {",
			"\t\treturn sz;",
			"\t}",
			"};",
			"",
			"template<class T>",
			"struct Dijkstra : public Graph<T> {",
			"\tDijkstra(int n) : Graph<T>(n) {}",
			"\tvoid Dijkstra_solve(int start, T INF_COST) {",
			"\t\tauto& v = this->v;",
			"\t\tauto& e = this->e;",
			"\t\tfor (auto& vv : v) vv.cost = INF_COST;",
			"\t\tusing Q_T = pair<T, int>;",
			"\t\tpriority_queue<Q_T, vector<Q_T>, greater<>> q;",
			"\t\tq.emplace(0, start);",
			"\t\twhile (!q.empty()) {",
			"\t\t\tauto a = q.top();",
			"\t\t\tq.pop();",
			"\t\t\tif (a.first >= v[a.second].cost) continue;",
			"\t\t\tv[a.second].cost = a.first;",
			"\t\t\tfor (auto& p : e[a.second]) {",
			"\t\t\t\tif (p.cost == INF_COST) continue;",
			"\t\t\t\tif (a.first + p.cost < v[p.to].cost) q.emplace(a.first + p.cost, p.to);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"};"
		]
	},
	"LazySegTree": {
		"prefix": "LazySegTree",
		"body": [
			"template <class NODE, class LAZY, NODE UNITY_NODE, LAZY UNITY_LAZY>",
			"struct LazySegTree {",
			"// edit start",
			"\tNODE merge(NODE a, NODE b) {",
			"//\t\treturn a + b;",
			"\t}",
			"\tLAZY add(LAZY a, LAZY b) {",
			"//\t\treturn a + b;",
			"\t}",
			"\tNODE reflect(NODE a, LAZY b) {",
			"//\t\treturn a + b;",
			"\t}",
			"\tLAZY propagate(LAZY a, int len) {",
			"//\t\treturn a;",
			"//\t\treturn a * len;",
			"\t}",
			"// edit end",
			"\tint n;",
			"\tvector<NODE> node;",
			"\tvector<LAZY> lazy;",
			"\tLazySegTree(int n_) {",
			"\t\tinit(n_);",
			"\t}",
			"\tinline void eval(int len, int k) {",
			"\t\tif (lazy[k] == UNITY_LAZY) return;",
			"\t\tif (k*2 + 1 < n*2 - 1) {",
			"\t\t\tlazy[k*2+1] = add(lazy[k*2+1], lazy[k]);",
			"\t\t\tlazy[k*2+2] = add(lazy[k*2+2], lazy[k]);",
			"\t\t}",
			"\t\tnode[k] = reflect(node[k], propagate(lazy[k], len));",
			"\t\tlazy[k] = UNITY_LAZY;",
			"\t}",
			"\tvoid init(int n_) {",
			"\t\tn = 1;",
			"\t\twhile (n < n_) n *= 2;",
			"\t\tnode.clear();",
			"\t\tlazy.clear();",
			"\t\tnode.assign(2*n-1, UNITY_NODE);",
			"\t\tlazy.assign(2*n-1, UNITY_LAZY);",
			"\t}",
			"\tvoid build(vector<NODE>& v, int n_ = -1) {",
			"\t\tif (n_ == -1) n_ = v.size();",
			"\t\tfor (int i = 0; i < n_; i++) node[i+n-1] = v[i];",
			"\t\tfor (int i = n-2; i >= 0; i--) node[i] = merge(node[i*2+1], node[i*2+2]);",
			"\t}",
			"\tNODE set(int a, int b, LAZY x, int k, int l, int r) {",
			"\t\teval(r-l, k);",
			"\t\tif (b <= l || r <= a) return node[k];",
			"\t\tif (a <= l && r <= b) {",
			"\t\t\tlazy[k] = add(lazy[k], x);",
			"\t\t\treturn reflect(node[k], propagate(lazy[k], r-l));",
			"\t\t}",
			"\t\treturn node[k] = merge(set(a, b, x, k*2+1, l, (l+r)/2),",
			"\t\t                       set(a, b, x, k*2+2, (l+r)/2, r));",
			"\t}",
			"\tNODE set(int a, int b, LAZY x) {",
			"\t\treturn set(a, b, x, 0, 0, n);",
			"\t}",
			"\tNODE get(int a, int b, int k, int l, int r) {",
			"\t\teval(r-l, k);",
			"\t\tif (b <= l || r <= a) return UNITY_NODE;",
			"\t\tif (a <= l && r <= b) return node[k];",
			"\t\tNODE vl = get(a, b, k*2+1, l, (l+r)/2);",
			"\t\tNODE vr = get(a, b, k*2+2, (l+r)/2, r);",
			"\t\treturn merge(vl, vr);",
			"\t}",
			"\tNODE get(int a, int b) {",
			"\t\treturn get(a, b, 0, 0, n);",
			"\t}",
			"/* Debug",
			"\tvoid print() {",
			"\t\tint x = 0;",
			"\t\tint nx = 2;",
			"\t\tcerr << \"NODE\" << endl;",
			"\t\tfor (int i = 0; i < 2 * n - 1; i++) {",
			"\t\t\tcerr << node[i] << \" \";",
			"\t\t\tif (i == x) {",
			"\t\t\t\tx += nx;",
			"\t\t\t\tnx *= 2;",
			"\t\t\t\tcerr << endl;",
			"\t\t\t}",
			"\t\t}",
			"\t\tx = 0;",
			"\t\tnx = 2;",
			"\t\tcerr << endl << endl;;",
			"\t\tcerr << \"LAZY\" << endl;",
			"\t\tfor (int i = 0; i < 2 * n - 1; i++) {",
			"\t\t\tcerr << lazy[i] << \" \";",
			"\t\t\tif (i == x) {",
			"\t\t\t\tx += nx;",
			"\t\t\t\tnx *= 2;",
			"\t\t\t\tcerr << endl;",
			"\t\t\t}",
			"\t\t}",
			"\t\tcerr << endl << endl;",
			"\t}",
			"*/",
			"};"
		]
	},
	"Union_Find_Weight": {
		"prefix": "Union_Find_Weight",
		"body": [
			"template<class Abel> struct Union_Find_Weight",
			"{",
			"\tvector<int> par;",
			"\tvector<Abel> diff_weight;",
			"\tint n;",
			"\tUnion_Find_Weight(int a, Abel SUM_UNITY = 0) {init(a, SUM_UNITY);}",
			"\tvoid init(int a, Abel SUM_UNITY) {",
			"\t\tn = a;",
			"\t\tpar.resize(n, -1);",
			"\t\tdiff_weight.resize(n, SUM_UNITY);",
			"\t}",
			"\tint root(int x) {",
			"\t\tif (par[x] < 0) return x;",
			"\t\tint r = root(par[x]);",
			"\t\tdiff_weight[x] += diff_weight[par[x]];",
			"\t\treturn par[x] = r;",
			"\t}",
			"\tAbel weight(int x) {",
			"\t\troot(x);",
			"\t\treturn diff_weight[x];",
			"\t}",
			"\tAbel diff(int x, int y) {",
			"\t\treturn weight(y) - weight(x);",
			"\t}",
			"\tbool same(int x, int y) {",
			"\t\treturn root(x) == root(y);",
			"\t}",
			"// weight(y) - weight(x) = w",
			"\tbool unite(int x, int y, Abel w) {",
			"\t\tw += weight(x);",
			"\t\tw -= weight(y);",
			"\t\tx = root(x);",
			"\t\ty = root(y);",
			"\t\tif (x == y) return false;",
			"\t\tif (size(x) < size(y)) swap(x, y), w = -w;",
			"\t\tpar[x] += par[y];",
			"\t\tpar[y] = x;",
			"\t\tdiff_weight[y] = w;",
			"\t\treturn true;",
			"\t}",
			"\tint size(int x) {",
			"\t\tx = root(x);",
			"\t\treturn -par[x];",
			"\t}",
			"};"
		]
	},
	"ModInt": {
		"prefix": "ModInt",
		"body": [
			"namespace mylib {",
			"template<int mod>",
			"struct ModInt {",
			"\tusing ll = long long;",
			"\tint x;",
			"\tconstexpr static int M = mod;",
			"\tModInt(ll x_) {",
			"\t\tx = x_ % mod;",
			"\t\tif (x < 0) x += mod;",
			"\t}",
			"\tModInt() : ModInt(0) {}",
			"\tinline ModInt& operator+=(const ModInt rhs) {",
			"\t\tx += rhs.x;",
			"\t\tx %= mod;",
			"\t\treturn (*this);",
			"\t}",
			"\tinline ModInt& operator-=(const ModInt rhs) {",
			"\t\t(*this) += -rhs;",
			"\t\treturn *this;",
			"\t}",
			"\tinline ModInt& operator*=(const ModInt rhs) {",
			"\t\tx = ((ll) x * rhs.x) % mod;",
			"\t\treturn *this;",
			"\t}",
			"\tinline ModInt& operator/=(ModInt rhs) {",
			"\t\treturn *this *= rhs.power(mod - 2);",
			"\t}",
			"\tinline ModInt power(ll p) {",
			"\t\tModInt res = 1;",
			"\t\tModInt a = x;",
			"\t\tfor (; p; res = p & 1 ? res * a : res, a *= a, p >>= 1);",
			"\t\treturn res;",
			"\t}",
			"\tinline ModInt& operator=(const ModInt& rhs) {",
			"\t\tthis->x = rhs.x;",
			"\t\treturn *this;",
			"\t}",
			"\tinline int operator==(const ModInt& rhs) const {",
			"\t\treturn this->x == rhs.x;",
			"\t}",
			"\tinline int operator!=(const ModInt& rhs) const {",
			"\t\treturn !(*this != rhs);",
			"\t}",
			"\tinline ModInt operator++(signed unused) {",
			"\t\tModInt res(*this);",
			"\t\t++(*this);",
			"\t\treturn res;",
			"\t}",
			"\tinline ModInt& operator++() {",
			"\t\t(*this) += 1;",
			"\t\treturn (*this);",
			"\t}",
			"\tinline ModInt operator--(signed unused) {",
			"\t\tModInt res(*this);",
			"\t\t--(*this);",
			"\t\treturn res;",
			"\t}",
			"\tinline ModInt& operator--() {",
			"\t\t(*this) -= 1;",
			"\t\treturn (*this);",
			"\t}",
			"\tinline ModInt operator+() const {",
			"\t\treturn (*this);",
			"\t}",
			"\tinline ModInt operator-() const {",
			"\t\treturn (*this).x ? ModInt(mod - (*this).x) : ModInt(0);",
			"\t}",
			"\tfriend const ModInt operator+(const ModInt& lhs, const ModInt& rhs) {return ModInt(lhs) += rhs;}",
			"\tfriend const ModInt operator-(const ModInt& lhs, const ModInt& rhs) {return ModInt(lhs) -= rhs;}",
			"\tfriend const ModInt operator*(const ModInt& lhs, const ModInt& rhs) {return ModInt(lhs) *= rhs;}",
			"\tfriend const ModInt operator/(const ModInt& lhs, const ModInt& rhs) {return ModInt(lhs) /= rhs;}",
			"\texplicit operator int() const {return x;}",
			"\tfriend ostream& operator<<(ostream& lhs, const ModInt& rhs) {",
			"\t\tlhs << rhs.x;",
			"\t\treturn lhs;",
			"\t}",
			"\tfriend istream& operator>>(istream& lhs, ModInt& rhs) {",
			"\t\tlong long t;",
			"\t\tlhs >> t;",
			"\t\trhs = ModInt(t);",
			"\t\treturn lhs;",
			"\t}",
			"};",
			"using modint = ModInt<MOD>;",
			"//using modint = ModInt<1000000007>;",
			"//using modint = ModInt<998244353>;",
			"modint operator\"\" _mi(unsigned long long lit) {",
			"\treturn modint(lit % modint::M);",
			"}",
			"}; // mylib",
			"using namespace mylib;"
		]
	},
	"Dinic": {
		"prefix": "Dinic",
		"body": [
			"template<class T>",
			"struct Graph",
			"{",
			"\tstruct Vertex{};",
			"\tstruct Edge {",
			"\t\tint to;",
			"\t\tT cap;",
			"\t\tint rev;",
			"\t\tEdge(int x, T y, int z) : to(x), cap(y), rev(z) {}",
			"\t};",
			"\tint sz;",
			"\tvector<Vertex> v;",
			"\tvector<vector<Edge>> e;",
			"\tGraph(int n) : sz(n), v(n), e(n) {}",
			"\ttemplate<class... Args>",
			"\tinline void assign_vertex(int pos, Args... args) {",
			"\t\tv[pos] = V(args...);",
			"\t}",
			"\t// from, to, cost",
			"\ttemplate<class... Args>",
			"\tinline void add_edge(int pos, Args... args) {",
			"\t\te[pos].emplace_back(args...);",
			"\t}",
			"\tinline int size() {",
			"\t\treturn sz;",
			"\t}",
			"};",
			"",
			"",
			"template<class T>",
			"struct Dinic : public Graph<T> {",
			"\tconst int FLOW_INF = INT_MAX;",
			"\tvector<int> level;",
			"\tvector<int> iter;",
			"// a:Vertex(|V|)",
			"\tDinic(int n) : Graph<T>(n), level(n), iter(n) {}",
			"// x:from y:to z:capacity",
			"\tvoid add_edge_dinic(int x, int y, T z) {",
			"\t\tthis->add_edge(x, y, z, this->e[y].size());",
			"\t\tthis->add_edge(y, x, 0, this->e[x].size()-1);",
			"\t}",
			"\tT dfs(int s, int t, T f) {",
			"\t\tif (s == t) return f;",
			"\t\tfor (int& i = iter[s]; i < (int) this->e[s].size(); i++) {",
			"\t\t\tauto& x = this->e[s][i];",
			"\t\t\tif (x.cap == 0 || level[s] >= level[x.to]) continue;",
			"\t\t\tT d;",
			"\t\t\tif ((d = dfs(x.to, t, min(f, x.cap))) > 0) {",
			"\t\t\t\tx.cap -= d;",
			"\t\t\t\tthis->e[x.to][x.rev].cap += d;",
			"\t\t\t\treturn d;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn 0;",
			"\t}",
			"\tvoid bfs(int s) {",
			"\t\tfill(level.begin(), level.end(), -1);",
			"\t\tqueue<pair<int, int>> q;",
			"\t\tq.push(make_pair(s, 0));",
			"\t\twhile (!q.empty()) {",
			"\t\t\tauto x = q.front();",
			"\t\t\tq.pop();",
			"\t\t\tint a = x.first;",
			"\t\t\tint b = x.second;",
			"\t\t\tif (level[a] != -1) continue;",
			"\t\t\tlevel[a] = b;",
			"\t\t\tfor (auto y : this->e[a]) {",
			"\t\t\t\tif (y.cap > 0) q.push(make_pair(y.to, b+1));",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tT Dinic_solve(int s, int t) {",
			"\t\tT res = 0;",
			"\t\twhile (true){",
			"\t\t\tbfs(s);",
			"\t\t\tif (level[t] < 0) return res;",
			"\t\t\tfill(iter.begin(), iter.end(), 0);",
			"\t\t\tT r;",
			"\t\t\tdo {",
			"\t\t\t\tr = dfs(s, t, FLOW_INF);",
			"\t\t\t\tres += r;",
			"\t\t\t} while (r);",
			"\t\t}",
			"\t}",
			"};"
		]
	},
	"logpow": {
		"prefix": "logpow",
		"body": [
			"template<class T>",
			"T logpow(T x, long long p)",
			"{",
			"\tif (p == 0) {",
			"\t\treturn 1;",
			"\t}",
			"\tif (p % 2) {",
			"\t\treturn x * logpow(x, p-1);",
			"\t}",
			"\tT t = logpow(x, p/2);",
			"\treturn t * t;",
			"}"
		]
	},
	"Bellmanford": {
		"prefix": "Bellmanford",
		"body": [
			"template<class T>",
			"struct Graph {",
			"\tstruct Vertex {",
			"\t\tT cost;",
			"\t\tbool valid = false; // \u5230\u9054\u4e0d\u80fd\u307e\u305f\u306f\u7121\u9650\u306b\u30b3\u30b9\u30c8\u304c\u6e1b\u308b\u3068\u304dfalse",
			"\t\tVertex(T v1) : cost(v1) {}",
			"\t\tVertex() {}",
			"\t};",
			"\tstruct Edge {",
			"\t\tint from;",
			"\t\tint to;",
			"\t\tT cost;",
			"\t\tEdge(int t, T c) : to(t), cost(c) {}",
			"\t\tEdge(int t, int u, T c) : from(t), to(u), cost(c) {}",
			"\t\tEdge() {}",
			"\t};",
			"\tint sz;",
			"\tvector<Vertex> v;",
			"\tvector<vector<Edge>> e;",
			"\tvector<Edge> edges;",
			"\tGraph(int n) : sz(n), v(n), e(n) {}",
			"\ttemplate<class... Args>",
			"\tinline void assign_vertex(int pos, Args... args) {",
			"\t\tv[pos] = V(args...);",
			"\t}",
			"\t// from, to, cost",
			"\ttemplate<class... Args>",
			"\tinline void add_edge(int pos, Args... args) {",
			"\t\te[pos].emplace_back(args...);",
			"\t\tedges.emplace_back(pos, args...);",
			"\t}",
			"\tinline int size() {",
			"\t\treturn sz;",
			"\t}",
			"};",
			"template<class T>",
			"struct Bellmanford : public Graph<T> {",
			"\tBellmanford(int n) : Graph<T>(n) {};",
			"\tvoid Bellman_solve(int s, T INF_COST) {",
			"\t\tauto& v = this->v;",
			"\t\tauto& e = this->e;",
			"\t\tfor (auto& vv : v) vv.cost = INF_COST, vv.valid = false;",
			"\t\tv[s].cost = 0, v[s].valid = true;",
			"\t\tfor (int i = 0; i + 1 < (int) v.size(); i++) {",
			"\t\t\tfor (auto& x: this->edges) {",
			"\t\t\t\tif (v[x.from].cost == INF_COST) continue;",
			"\t\t\t\tv[x.to].cost = min(v[x.to].cost, v[x.from].cost + x.cost);",
			"\t\t\t\tv[x.to].valid = true;",
			"\t\t\t}",
			"\t\t}",
			"\t\tauto valid_check = [&](auto f, int pos) {",
			"\t\t\tif (!v[pos].valid) return;",
			"\t\t\tv[pos].valid = false;",
			"\t\t\tfor (auto& y: e[pos]) {",
			"\t\t\t\tf(f, y.to);",
			"\t\t\t}",
			"\t\t};",
			"\t\tfor (int i = 0; i < (int) v.size(); i++) {",
			"\t\t\tfor (auto& x: e[i]) {",
			"\t\t\t\tif (v[i].cost == INF_COST) continue;",
			"\t\t\t\tif (v[x.to].cost > v[i].cost + x.cost) {",
			"\t\t\t\t\tvalid_check(valid_check, x.to);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"};"
		]
	},
	"BIT": {
		"prefix": "BIT",
		"body": [
			"template<class T>",
			"struct BIT {",
			"\tint n;",
			"\tvector<T> bit;",
			"\tBIT(int n_) {",
			"\t\tn = n_;",
			"\t\tbit.resize(n+1);",
			"\t}",
			"\tvoid add(int x, T v) {",
			"\t\tfor (int i = x+1; i <= n; i += i & -i) {",
			"\t\t\tbit[i] += v;",
			"\t\t}",
			"\t}",
			"\tT get(int x) {",
			"\t\tT res = 0;",
			"\t\tfor (int i = x+1; i; i -= i & -i) {",
			"\t\t\tres += bit[i];",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"};"
		]
	},
	"BIT_2D": {
		"prefix": "BIT_2D",
		"body": [
			"template<class T>",
			"struct BIT_2D {",
			"\tint R, C;",
			"\tvector<vector<T>> bit;",
			"\tBIT_2D(int r, int c) {",
			"\t\tR = r;",
			"\t\tC = c;",
			"\t\tbit.resize(r+1, vector<T>(c+1, 0));",
			"\t}",
			"\tvoid add(int r, int c, T v) {",
			"\t\tfor (int i = r+1; i <= R; i += i & -i) {",
			"\t\t\tfor (int j = c+1; j <= C; j += j & -j) {",
			"\t\t\t\tbit[i][j] += v;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tT get(int r, int c) {",
			"\t\tT res = 0;",
			"\t\tfor (int i = r+1; i; i -= i & -i) {",
			"\t\t\tfor (int j = c+1; j; j -= j & -j) {",
			"\t\t\t\tres += bit[i][j];",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"// bit[r1][c1] ~~ bit[r2 - 1][c2 - 1]",
			"\tT get_sum(int r1, int c1, int r2, int c2) {",
			"\t\tr1--; c1--; r2--; c2--;",
			"\t\treturn get(r2, c2) - get(r1, c2) - get(r2, c1) + get(r1, c1);",
			"\t}",
			"};"
		]
	},
	"class4": {
		"prefix": "class4",
		"body": [
			"struct $1",
			"{",
			"\t$2 $6;",
			"\t$3 $7;",
			"\t$4 $8;",
			"\t$5 $9; ",
			"\t$1($2 v1, $3 v2, $4 v3, $5 v4) : $6(v1), $7(v2), $8(v3) , $9(v4) {}",
			"\t$1() {}",
			"\tbool operator<(const $1 r) const {",
			"\t\tif ($6 == r.$6) {",
			"\t\t\tif ($7 == r.$7) {",
			"\t\t\t\tif ($8 == r.$8) {",
			"\t\t\t\t\treturn $9 < r.$9;",
			"\t\t\t\t} else {",
			"\t\t\t\t\treturn $8 < r.$8;",
			"\t\t\t\t}",
			"\t\t\t} else {",
			"\t\t\t\treturn $7 < r.$7;",
			"\t\t\t}",
			"\t\t} else {",
			"\t\t\treturn $6 < r.$6;",
			"\t\t}",
			"\t}",
			"\tbool operator>(const $1 r) const {",
			"\t\treturn r < *this;",
			"\t}",
			"\tbool operator>=(const $1 r) const {",
			"\t\treturn !(*this < r);",
			"\t}",
			"\tbool operator<=(const $1 r) const {",
			"\t\treturn !(r < *this);",
			"\t}",
			"\tbool operator==(const $1 r) const {",
			"\t\treturn !(r < *this) && !(*this < r);",
			"\t}",
			"\tbool operator!=(const $1 r) const {",
			"\t\treturn (r < *this) || (*this < r);",
			"\t}",
			"};"
		]
	},
	"extgcd": {
		"prefix": "extgcd",
		"body": [
			"// ax + by = gcd(a, b) \u3092\u89e3\u304f",
			"template<class T>",
			"T extgcd(T a, T b, T& x, T& y) {",
			"\tT d = a;",
			"\tif (b == 0) {",
			"\t\tx = 1;",
			"\t\ty = 0;",
			"\t} else {",
			"\t\td = extgcd(b, a%b, y, x);",
			"\t\ty -= a / b * x;",
			"\t}",
			"\treturn d;",
			"}"
		]
	},
	"RSQ_RAQ": {
		"prefix": "RSQ_RAQ",
		"body": [
			"/*",
			"\tUNITY_NODE sum\u306e\u5358\u4f4d\u5143",
			"\tUNITY_LAZY add\u306e\u5358\u4f4d\u5143",
			"\tnode\u306e\u521d\u671f\u5024\u306b\u6ce8\u610f(init)",
			"\tadd\u306e\u547c\u3073\u51fa\u3057\u5143\u306b\u6ce8\u610f(\u533a\u9593\u306e\u9577\u3055\u306b\u6bd4\u4f8b\u3059\u308b)",
			"*/",
			"template <class NODE, class LAZY, NODE UNITY_NODE, LAZY UNITY_LAZY>",
			"struct LazySegTree {",
			"// edit start",
			"\tvoid add(LAZY &a, LAZY b) {",
			"\t\ta += b;",
			"\t}",
			"\tvoid reflect(NODE& a, LAZY b, int l, int r) {",
			"\t\ta += b;",
			"\t}",
			"\tNODE merge(NODE a, NODE b) {",
			"\t\treturn a + b;",
			"\t}",
			"// end",
			"\tint n;",
			"\tvector<NODE> node;",
			"\tvector<LAZY> lazy;",
			"\tLazySegTree(int sz) {",
			"\t\tinit(sz);",
			"\t}",
			"\tvoid init(int sz) {",
			"\t\tn = 1;",
			"\t\twhile (n < sz) n *= 2;",
			"\t\tnode.assign(2*n-1, 0);",
			"\t\tlazy.assign(2*n-1, UNITY_LAZY);",
			"\t}",
			"\tvoid eval(int l, int r, int k) {",
			"\t\treflect(node[k], lazy[k], l, r);",
			"\t\tif (r - l > 1) {",
			"\t\t\tadd(lazy[k*2+1], lazy[k] / 2);",
			"\t\t\tadd(lazy[k*2+2], lazy[k] / 2);",
			"\t\t}",
			"\t\tlazy[k] = UNITY_LAZY;",
			"\t}",
			"\tvoid renode(int k) {",
			"\t\tnode[k] = merge(node[k*2+1], node[k*2+2]);",
			"\t}",
			"\tvoid set(int a, int b, LAZY x, int k=0, int l=0, int r=-1) {",
			"\t\tif (r < 0) r = n;",
			"\t\tif (b <= l || r <= a) {",
			"\t\t\teval(l, r, k);",
			"\t\t} else if (a <= l && r <= b) {",
			"\t\t\tadd(lazy[k], x * (r - l));",
			"\t\t\teval(l, r, k);",
			"\t\t} else {",
			"\t\t\teval(l, r, k);",
			"\t\t\tset(a, b, x, k*2+1, l, (l+r) / 2);",
			"\t\t\tset(a, b, x, k*2+2, (l+r) / 2, r);",
			"\t\t\trenode(k);",
			"\t\t}",
			"\t}",
			"\tNODE get(int a, int b, int k=0, int l=0, int r=-1) {",
			"\t\tif (r < 0) r = n;",
			"\t\teval(l, r, k);",
			"\t\tif (b <= l || r <= a) {",
			"\t\t\treturn UNITY_NODE;",
			"\t\t} else if (a <= l && r <= b) {",
			"\t\t\treturn node[k];",
			"\t\t} else {",
			"\t\t\tNODE t1 = get(a, b, 2*k+1, l, (l+r) / 2);",
			"\t\t\tNODE t2 = get(a, b, 2*k+2, (l+r) / 2, r);",
			"\t\t\trenode(k);",
			"\t\t\treturn merge(t1, t2);",
			"\t\t}",
			"\t}",
			"};"
		]
	},
	"ModComb": {
		"prefix": "ModComb",
		"body": [
			"template<class T>",
			"struct ModComb {",
			"\tvector<T> fact;",
			"\tvector<T> facti;",
			"\tModComb(int n) : fact(n+1), facti(n+1) {",
			"\t\tfact[0] = 1;",
			"\t\tfor (int i = 1; i < n + 1; i++) {",
			"\t\t\tfact[i] = fact[i-1] * i;",
			"\t\t}",
			"\t\tfacti[n] = 1 / fact[n];",
			"\t\tfor (int i = n-1; i >= 0; i--) {",
			"\t\t\tfacti[i] = facti[i+1] * (i + 1);",
			"\t\t}",
			"\t}",
			"\tT C(int n, int r) const {",
			"\t\tif(n < 0 || r < 0 || n < r) return 0;",
			"\t\treturn fact[n] * facti[r] * facti[n-r];",
			"\t}",
			"\tT P(int n, int r) const {",
			"\t\tif(n < 0 || r < 0 || n < r) return 0;",
			"\t\treturn fact[n] * facti[n-r];",
			"\t}",
			"\tT H(int n, int r) const {",
			"\t\tif(n < 0 || r < 0) return 0;",
			"\t\treturn C(n + r - 1, r);",
			"\t}",
			"};",
			"using modcomb = ModComb<modint>;"
		]
	},
	"RollingHash": {
		"prefix": "RollingHash",
		"body": [
			"template<class m1 = ModInt<1000000007>, class m2 = ModInt<1000000009>>",
			"struct RollingHash {",
			"\tint base1;",
			"\tint base2;",
			"\tint sz;",
			"\tvector<m1> hash1;",
			"\tvector<m2> hash2;",
			"\tvector<m1> pow1;",
			"\tvector<m2> pow2;",
			"\tRollingHash(const string& s) : base1(1009), base2(1007), sz(s.length()), hash1(sz + 1, 0), hash2(sz + 1, 0), pow1(sz + 1, 1), pow2(sz + 1, 1) {",
			"\t\tfor (int i = 0; i < sz; i++) {",
			"\t\t\thash1[i+1] = (hash1[i] + s[i]) * base1;",
			"\t\t\thash2[i+1] = (hash2[i] + s[i]) * base2;",
			"\t\t\tpow1[i+1] = pow1[i] * base1;",
			"\t\t\tpow2[i+1] = pow2[i] * base2;",
			"\t\t}",
			"\t}",
			"",
			"\tlong long get(int l, int r) {",
			"\t\tm1 t1 = hash1[r] - hash1[l] * pow1[r - l];",
			"\t\tm2 t2 = hash2[r] - hash2[l] * pow2[r - l];",
			"\t\treturn (long long) t1.x * t2.M + t2.x;",
			"\t}",
			"};"
		]
	},
	"Factorize": {
		"prefix": "Factorize",
		"body": [
			"template<class T>",
			"void Factorize(T n, map<T, int>& res) {",
			"\tfor (T i = 2; i * i <= n; i++) {",
			"\t\twhile (n % i == 0) {",
			"\t\t\tres[i]++;",
			"\t\t\tn /= i;",
			"\t\t}",
			"\t}",
			"\tif (n != 1) res[n]++;",
			"}",
			"template<class T>",
			"void Factorize(T n, vector<int>& res) {",
			"\tfor (T i = 2; i * i <= n; i++) {",
			"\t\twhile (n % i == 0) {",
			"\t\t\tres.push_back(i);",
			"\t\t\tn /= i;",
			"\t\t}",
			"\t}",
			"\tif (n != 1) res.push_back(n);",
			"}"
		]
	},
	"LCS": {
		"prefix": "LCS",
		"body": [
			"template<class T>",
			"int LCS(const T& a, const T& b) {",
			"\tvector<vector<int>> dp(a.size() + 1, vector<int>(b.size() + 1));",
			"\tfor (size_t i = 0; i < a.size(); i++) {",
			"\t\tfor (size_t j = 0; j < b.size(); j++) {",
			"\t\t\tint& r = dp[i+1][j+1];",
			"\t\t\tr = max(dp[i][j+1], dp[i+1][j]);",
			"\t\t\tif (a[i] == b[j]) r = max(r, dp[i][j] + 1);",
			"\t\t}",
			"\t}",
			"\treturn dp[a.size()][b.size()];",
			"}"
		]
	},
	"meguru": {
		"prefix": "meguru",
		"body": [
			"// meguru<T>(ok, ng, isok)\u3067\u547c\u3076",
			"template<class T>",
			"T meguru(T ok, T ng, function<bool(T)> isok) {",
			"\twhile (abs(ok - ng) > 1) {",
			"\t\tT mid = (ok + ng) / 2;",
			"\t\tif (isok(mid)) ok = mid;",
			"\t\telse ng = mid;",
			"\t}",
			"\treturn ok;",
			"}"
		]
	},
	"RMQ_RUQ": {
		"prefix": "RMQ_RUQ",
		"body": [
			"/*",
			"\tUNITY_NODE min\u306e\u5358\u4f4d\u5143",
			"\tUNITY_LAZY update\u306e\u5358\u4f4d\u5143",
			"\tnode\u306e\u521d\u671f\u5024\u306b\u6ce8\u610f(init)",
			"*/",
			"template <class NODE, class LAZY, NODE UNITY_NODE, LAZY UNITY_LAZY>",
			"struct LazySegTree {",
			"// edit start",
			"\tvoid add(LAZY &a, LAZY b) {",
			"\t\tif (b == UNITY_LAZY) return;",
			"\t\ta = b;",
			"\t}",
			"\tvoid reflect(NODE& a, LAZY b, int l, int r) {",
			"\t\tif (b == UNITY_LAZY) return;",
			"\t\ta = b;",
			"\t}",
			"\tNODE merge(NODE a, NODE b) {",
			"\t\treturn min(a, b);",
			"\t}",
			"// end",
			"\tint n;",
			"\tvector<NODE> node;",
			"\tvector<LAZY> lazy;",
			"\tLazySegTree(int sz) {",
			"\t\tinit(sz);",
			"\t}",
			"\tvoid init(int sz) {",
			"\t\tn = 1;",
			"\t\twhile (n < sz) n *= 2;",
			"\t\tnode.assign(2*n-1, UNITY_NODE);",
			"\t\tlazy.assign(2*n-1, UNITY_LAZY);",
			"\t}",
			"\tvoid eval(int l, int r, int k) {",
			"\t\treflect(node[k], lazy[k], l, r);",
			"\t\tif (r - l > 1) {",
			"\t\t\tadd(lazy[k*2+1], lazy[k]);",
			"\t\t\tadd(lazy[k*2+2], lazy[k]);",
			"\t\t}",
			"\t\tlazy[k] = UNITY_LAZY;",
			"\t}",
			"\tvoid renode(int k) {",
			"\t\tnode[k] = merge(node[k*2+1], node[k*2+2]);",
			"\t}",
			"\tvoid set(int a, int b, LAZY x, int k=0, int l=0, int r=-1) {",
			"\t\tif (r < 0) r = n;",
			"\t\tif (b <= l || r <= a) {",
			"\t\t\teval(l, r, k);",
			"\t\t} else if (a <= l && r <= b) {",
			"\t\t\tadd(lazy[k], x);",
			"\t\t\teval(l, r, k);",
			"\t\t} else {",
			"\t\t\teval(l, r, k);",
			"\t\t\tset(a, b, x, k*2+1, l, (l+r) / 2);",
			"\t\t\tset(a, b, x, k*2+2, (l+r) / 2, r);",
			"\t\t\trenode(k);",
			"\t\t}",
			"\t}",
			"\tNODE get(int a, int b, int k=0, int l=0, int r=-1) {",
			"\t\tif (r < 0) r = n;",
			"\t\teval(l, r, k);",
			"\t\tif (b <= l || r <= a) {",
			"\t\t\treturn UNITY_NODE;",
			"\t\t} else if (a <= l && r <= b) {",
			"\t\t\treturn node[k];",
			"\t\t} else {",
			"\t\t\tNODE t1 = get(a, b, 2*k+1, l, (l+r) / 2);",
			"\t\t\tNODE t2 = get(a, b, 2*k+2, (l+r) / 2, r);",
			"\t\t\trenode(k);",
			"\t\t\treturn merge(t1, t2);",
			"\t\t}",
			"\t}",
			"};"
		]
	},
	"Diameter": {
		"prefix": "Diameter",
		"body": [
			"template<class T>",
			"struct Graph",
			"{",
			"\tstruct Vertex{};",
			"\tstruct Edge {",
			"\t\tint to;",
			"\t\tint cost;",
			"\t\tEdge(int t, int c) : to(t), cost(c) {}",
			"\t\tEdge() {}",
			"\t};",
			"\tint sz;",
			"\tvector<Vertex> v;",
			"\tvector<vector<Edge>> e;",
			"\tGraph(int n) : sz(n), v(n), e(n) {}",
			"\ttemplate<class... Args>",
			"\tinline void assign_vertex(int pos, Args... args) {",
			"\t\tv[pos] = V(args...);",
			"\t}",
			"\ttemplate<class... Args>",
			"\tinline void add_edge(int pos, Args... args) {",
			"\t\te[pos].emplace_back(args...);",
			"\t}",
			"\tinline int size() {",
			"\t\treturn sz;",
			"\t}",
			"};",
			"template<class T>",
			"struct Diameter : public Graph<T> {",
			"\tDiameter(int n) : Graph<T>(n) {}",
			"\tint Diameter_solve() {",
			"\t\tauto dfs = [this](auto f, int start, int& goal, int par = -1) -> int {",
			"\t\t\tgoal = start;",
			"\t\t\tint res = 0;",
			"\t\t\tfor (auto& i: this->e[start]) {",
			"\t\t\t\tif (i.to == par) continue;",
			"\t\t\t\tint t;",
			"\t\t\t\tint r = f(f, i.to, t, start);",
			"\t\t\t\tr += i.cost;",
			"\t\t\t\tif (r > res) {",
			"\t\t\t\t\tres = r;",
			"\t\t\t\t\tgoal = t;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\treturn res;",
			"\t\t};",
			"\t\tint g;",
			"\t\tdfs(dfs, 0, g);",
			"\t\treturn dfs(dfs, g, g);",
			"\t}",
			"};"
		]
	},
	"Kruskal": {
		"prefix": "Kruskal",
		"body": [
			"template<class T>",
			"struct Graph {",
			"\tstruct Vertex {};",
			"\tstruct Edge {",
			"\t\tint from;",
			"\t\tint to;",
			"\t\tT cost;",
			"\t\tEdge(int t, T c) : to(t), cost(c) {}",
			"\t\tEdge(int t, int u, T c) : from(t), to(u), cost(c) {}",
			"\t\tbool operator<(const Edge& r) {",
			"\t\t\treturn this->cost < r.cost;",
			"\t\t}",
			"\t\tEdge() {}",
			"\t};",
			"\tint sz;",
			"\tvector<Vertex> v;",
			"\tvector<vector<Edge>> e;",
			"\tvector<Edge> edges;",
			"\tGraph(int n) : sz(n), v(n), e(n) {}",
			"\ttemplate<class... Args>",
			"\tinline void assign_vertex(int pos, Args... args) {",
			"\t\tv[pos] = V(args...);",
			"\t}",
			"\t// from, to, cost",
			"\ttemplate<class... Args>",
			"\tinline void add_edge(int pos, Args... args) {",
			"\t\te[pos].emplace_back(args...);",
			"\t}",
			"\tinline int size() {",
			"\t\treturn sz;",
			"\t}",
			"};",
			"",
			"template<class T>",
			"struct Kruskal : public Graph<T> {",
			"\tKruskal(int n) : Graph<T>(n) {};",
			"\ttemplate<class... Args>",
			"\tvoid Kruskal_add_edge(int pos, Args... args) {",
			"\t\tthis->e[pos].emplace_back(args...);",
			"\t\tthis->edges.emplace_back(pos, args...);",
			"\t}",
			"\tT Kruskal_solve() {",
			"\t\tsort(this->edges.begin(), this->edges.end());",
			"\t\tUnionFind u(this->sz);",
			"\t\tT res = 0;",
			"\t\tfor (auto &x : this->edges) {",
			"\t\t\tif (u.unite(x.from, x.to)) res += x.cost;",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"};"
		]
	},
	"class3": {
		"prefix": "class3",
		"body": [
			"struct $1",
			"{",
			"\t$2 $5;",
			"\t$3 $6;",
			"\t$4 $7;",
			"\t$1($2 v1, $3 v2, $4 v3) : $5(v1), $6(v2), $7(v3) {}",
			"\t$1() {}",
			"\tbool operator<(const $1 r) const {",
			"\t\tif ($5 == r.$5) {",
			"\t\t\tif ($6 == r.$6) {",
			"\t\t\t\treturn $7 < r.$7;",
			"\t\t\t} else {",
			"\t\t\t\treturn $6 < r.$6;",
			"\t\t\t}",
			"\t\t} else {",
			"\t\t\treturn $5 < r.$5;",
			"\t\t}",
			"\t}",
			"\tbool operator>(const $1 r) const {",
			"\t\treturn r < *this;",
			"\t}",
			"\tbool operator>=(const $1 r) const {",
			"\t\treturn !(*this < r);",
			"\t}",
			"\tbool operator<=(const $1 r) const {",
			"\t\treturn !(r < *this);",
			"\t}",
			"\tbool operator==(const $1 r) const {",
			"\t\treturn !(r < *this) && !(*this < r);",
			"\t}",
			"\tbool operator!=(const $1 r) const {",
			"\t\treturn (r < *this) || (*this < r);",
			"\t}",
			"};"
		]
	},
	"class5": {
		"prefix": "class5",
		"body": [
			"struct $1",
			"{",
			"\t$2 $7;",
			"\t$3 $8;",
			"\t$4 $9;",
			"\t$5 $10; ",
			"\t$6 $11;",
			"\t$1($2 v1, $3 v2, $4 v3, $5 v4, $6 v5) : $7(v1), $8(v2), $9(v3), $10(v4), $11(v5) {}",
			"\t$1() {}",
			"\tbool operator<(const $1 r) const {",
			"\t\tif ($7 == r.$7) {",
			"\t\t\tif ($8 == r.$8) {",
			"\t\t\t\tif ($9 == r.$9) {",
			"\t\t\t\t\tif ($10 == r.$10) {",
			"\t\t\t\t\t\treturn $11 < r.$11;",
			"\t\t\t\t\t} else {",
			"\t\t\t\t\t\treturn $10 < r.$10;",
			"\t\t\t\t\t}",
			"\t\t\t\t} else {",
			"\t\t\t\t\treturn $9 < r.$9;",
			"\t\t\t\t}",
			"\t\t\t} else {",
			"\t\t\t\treturn $8 < r.$8;",
			"\t\t\t}",
			"\t\t} else {",
			"\t\t\treturn $7 < r.$7;",
			"\t\t}",
			"\t}",
			"\tbool operator>(const $1 r) const {",
			"\t\treturn r < *this;",
			"\t}",
			"\tbool operator>=(const $1 r) const {",
			"\t\treturn !(*this < r);",
			"\t}",
			"\tbool operator<=(const $1 r) const {",
			"\t\treturn !(r < *this);",
			"\t}",
			"\tbool operator==(const $1 r) const {",
			"\t\treturn !(r < *this) && !(*this < r);",
			"\t}",
			"\tbool operator!=(const $1 r) const {",
			"\t\treturn (r < *this) || (*this < r);",
			"\t}",
			"};"
		]
	},
	"RSQ_RUQ": {
		"prefix": "RSQ_RUQ",
		"body": [
			"/*",
			"\tUNITY_NODE sum\u306e\u5358\u4f4d\u5143",
			"\tUNITY_LAZY update\u306e\u5358\u4f4d\u5143",
			"\tnode\u306e\u521d\u671f\u5024\u306b\u6ce8\u610f(init)",
			"\tadd\u306e\u547c\u3073\u51fa\u3057\u5143\u306b\u6ce8\u610f(\u533a\u9593\u306e\u9577\u3055\u306b\u6bd4\u4f8b\u3059\u308b)",
			"\t\u4e0a\u306e\u95a2\u4fc2\u3067UNITY_LAZY / 2\u3082\u5358\u4f4d\u5143\u3068\u307f\u306a\u3057\u3066\u3044\u308b",
			"*/",
			"template <class NODE, class LAZY, NODE UNITY_NODE, LAZY UNITY_LAZY>",
			"struct LazySegTree {",
			"// edit start",
			"\tvoid add(LAZY &a, LAZY b) {",
			"\t\tif (b == UNITY_LAZY || b == UNITY_LAZY / 2) return;",
			"\t\ta = b;",
			"\t}",
			"\tvoid reflect(NODE& a, LAZY b, int l, int r) {",
			"\t\tif (b == UNITY_LAZY || b == UNITY_LAZY / 2) return;",
			"\t\ta = b;",
			"\t}",
			"\tNODE merge(NODE a, NODE b) {",
			"\t\treturn a + b;",
			"\t}",
			"// end",
			"\tint n;",
			"\tvector<NODE> node;",
			"\tvector<LAZY> lazy;",
			"\tLazySegTree(int sz) {",
			"\t\tinit(sz);",
			"\t}",
			"\tvoid init(int sz) {",
			"\t\tn = 1;",
			"\t\twhile (n < sz) n *= 2;",
			"\t\tnode.assign(2*n-1, 0);",
			"\t\tlazy.assign(2*n-1, UNITY_LAZY);",
			"\t}",
			"\tvoid eval(int l, int r, int k) {",
			"\t\treflect(node[k], lazy[k], l, r);",
			"\t\tif (r - l > 1) {",
			"\t\t\tadd(lazy[k*2+1], lazy[k] / 2);",
			"\t\t\tadd(lazy[k*2+2], lazy[k] / 2);",
			"\t\t}",
			"\t\tlazy[k] = UNITY_LAZY;",
			"\t}",
			"\tvoid renode(int k) {",
			"\t\tnode[k] = merge(node[k*2+1], node[k*2+2]);",
			"\t}",
			"\tvoid set(int a, int b, LAZY x, int k=0, int l=0, int r=-1) {",
			"\t\tif (r < 0) r = n;",
			"\t\tif (b <= l || r <= a) {",
			"\t\t\teval(l, r, k);",
			"\t\t} else if (a <= l && r <= b) {",
			"\t\t\tadd(lazy[k], x * (r - l));",
			"\t\t\teval(l, r, k);",
			"\t\t} else {",
			"\t\t\teval(l, r, k);",
			"\t\t\tset(a, b, x, k*2+1, l, (l+r) / 2);",
			"\t\t\tset(a, b, x, k*2+2, (l+r) / 2, r);",
			"\t\t\trenode(k);",
			"\t\t}",
			"\t}",
			"\tNODE get(int a, int b, int k=0, int l=0, int r=-1) {",
			"\t\tif (r < 0) r = n;",
			"\t\teval(l, r, k);",
			"\t\tif (b <= l || r <= a) {",
			"\t\t\treturn UNITY_NODE;",
			"\t\t} else if (a <= l && r <= b) {",
			"\t\t\treturn node[k];",
			"\t\t} else {",
			"\t\t\tNODE t1 = get(a, b, 2*k+1, l, (l+r) / 2);",
			"\t\t\tNODE t2 = get(a, b, 2*k+2, (l+r) / 2, r);",
			"\t\t\trenode(k);",
			"\t\t\treturn merge(t1, t2);",
			"\t\t}",
			"\t}",
			"};"
		]
	},
	"LCA": {
		"prefix": "LCA",
		"body": [
			"struct Graph {",
			"\tstruct Vertex{};",
			"\tstruct Edge {",
			"\t\tint to;",
			"\t\tEdge(int t) : to(t) {}",
			"\t\tEdge() {}",
			"\t};",
			"\tint sz;",
			"\tvector<Vertex> v;",
			"\tvector<vector<Edge>> e;",
			"\tGraph(int n) : sz(n), v(n), e(n) {}",
			"\ttemplate<class... Args>",
			"\tinline void assign_vertex(int pos, Args... args) {",
			"\t\tv[pos] = V(args...);",
			"\t}",
			"\ttemplate<class... Args>",
			"\tinline void add_edge(int pos, Args... args) {",
			"\t\te[pos].emplace_back(args...);",
			"\t}",
			"\tinline int size() {",
			"\t\treturn sz;",
			"\t}",
			"};",
			"struct LCA : public Graph {",
			"\tvector<vector<int>> lca_dp;",
			"\tvector<int> depth;",
			"\tint log2_n;",
			"\tLCA(int n) : Graph(n), depth(sz, -100000) {}",
			"\tvoid lca_build(int root) {",
			"\t\tlog2_n = 0;",
			"\t\tfor (int t = sz; t; t /= 2, log2_n++);",
			"\t\tlca_dp.resize(log2_n, vector<int>(sz, -1));",
			"\t\tlca_dfs(root);",
			"\t\tfor (int i = 1; i < log2_n; i++) {",
			"\t\t\tfor (int j = 0; j < sz; j++) {",
			"\t\t\t\tif (lca_dp[i-1][j] == -1) lca_dp[i][j] = -1;",
			"\t\t\t\telse lca_dp[i][j] = lca_dp[i-1][lca_dp[i-1][j]];",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tvoid lca_dfs(int root) {",
			"\t\tstack<tuple<int, int, int>> s;",
			"\t\ts.emplace(root, -1, 0);",
			"\t\twhile (!s.empty()) {",
			"\t\t\tint now, par, d;",
			"\t\t\ttie(now, par, d) = s.top(); s.pop();",
			"\t\t\tlca_dp[0][now] = par;",
			"\t\t\tdepth[now] = d;",
			"\t\t\tfor (auto& x: e[now]) {",
			"\t\t\t\tif (x.to != par) s.emplace(x.to, now, d+1);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tint get_lca(int a, int b) {",
			"\t\tif (depth[a] > depth[b]) swap(a, b);",
			"\t\tfor (int i = log2_n - 1; i >= 0 ; i--) {",
			"\t\t\tif (((depth[b] - depth[a]) >> i) & 1) b = lca_dp[i][b];",
			"\t\t}",
			"\t\tif (a == b) return a;",
			"\t\tfor (int i = log2_n - 1; i >= 0; i--) {",
			"\t\t\tif (lca_dp[i][a] != lca_dp[i][b]) {",
			"\t\t\t\ta = lca_dp[i][a];",
			"\t\t\t\tb = lca_dp[i][b];",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn lca_dp[0][a];",
			"\t}",
			"\tint lca_distace(int a, int b) {",
			"\t\treturn depth[a] + depth[b] - 2 * depth[get_lca(a, b)];",
			"\t}",
			"};"
		]
	}
}