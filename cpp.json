{
	"RedBlackSet": {
		"prefix": "RedBlackSet",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"using namespace std;",
			"",
			"namespace spihill {",
			"template<class T>",
			"class RedBlackSetIterator;",
			"",
			"template<class T, class Compare = less<T>>",
			"struct RedBlackSet {",
			"\tstruct NODE;",
			"\tstruct NODE_LIST;",
			"\tfriend RedBlackSetIterator<T>;",
			"\tusing iterator = RedBlackSetIterator<T>;",
			"\tNODE_LIST list_dummy;",
			"\tNODE node_dummy;",
			"\tRedBlackSet() {",
			"\t\tnode_dummy.index = &list_dummy;",
			"\t\tlist_dummy.node = &node_dummy;",
			"\t}",
			"\tRedBlackSet(const RedBlackSet& R) {",
			"\t\tnode_dummy.index = &list_dummy;",
			"\t\tnode_dummy.left_size = R.node_dummy.left_size;",
			"\t\tlist_dummy.node = &node_dummy;",
			"\t\tauto dfs = [&](auto f, NODE* old_node, NODE* new_node) {",
			"\t\t\tif (0) return new_node;",
			"\t\t\tif (old_node->left) {",
			"\t\t\t\tnew_node->left = f(f, old_node->left, new NODE((T&&) *(old_node->left->key), new_node));",
			"\t\t\t}",
			"\t\t\tauto l = new NODE_LIST(&list_dummy, true);",
			"\t\t\tl->node = new_node;",
			"\t\t\tnew_node->index = l;",
			"\t\t\tnew_node->red = old_node->red;",
			"\t\t\tnew_node->left_size = old_node->left_size;",
			"\t\t\tnew_node->right_size = old_node->right_size;",
			"\t\t\tif (old_node->right) {",
			"\t\t\t\tnew_node->right = f(f, old_node->right, new NODE((T&&) *(old_node->right->key), new_node));",
			"\t\t\t}",
			"\t\t\treturn new_node;",
			"\t\t};",
			"\t\tif (R.node_dummy.left) node_dummy.left = dfs(dfs, R.node_dummy.left, new NODE((T&&) *(R.node_dummy.left->key), &node_dummy));",
			"\t}",
			"\t~RedBlackSet() {",
			"\t\tfor (NODE_LIST* p = list_dummy.fp; p != &list_dummy;) {",
			"\t\t\tp = p->fp;",
			"\t\t\tdelete p->bp;",
			"\t\t}",
			"\t}",
			"\tint size() {",
			"\t\treturn node_dummy.left_size;",
			"\t}",
			"\titerator begin() {",
			"\t\treturn iterator(list_dummy.fp);",
			"\t}",
			"\titerator end() {",
			"\t\treturn iterator(&list_dummy);",
			"\t}",
			"\titerator lower_bound(T&& v) {",
			"\t\tNODE* now = node_dummy.left;",
			"\t\tNODE* ans = nullptr;",
			"\t\twhile (now != nullptr) {",
			"\t\t\tif (Compare()(*(now->key), v)) {",
			"\t\t\t\tnow = now->right;",
			"\t\t\t}",
			"\t\t\telse {",
			"\t\t\t\tans = now;",
			"\t\t\t\tnow = now->left;",
			"\t\t\t}",
			"\t\t}",
			"\t\tif (ans) return iterator(ans->index);",
			"\t\treturn iterator(&list_dummy);",
			"\t}",
			"\titerator lower_bound(const T& v) {",
			"\t\treturn lower_bound((T&&) v);",
			"\t}",
			"\titerator upper_bound(T&& v) {",
			"\t\tNODE* now = node_dummy.left;",
			"\t\tNODE* ans = nullptr;",
			"\t\twhile (now != nullptr) {",
			"\t\t\tif (Compare()(v, *(now->key))) {",
			"\t\t\t\tans = now;",
			"\t\t\t\tnow = now->left;",
			"\t\t\t}",
			"\t\t\telse {",
			"\t\t\t\tnow = now->right;",
			"\t\t\t}",
			"\t\t}",
			"\t\tif (ans) return iterator(ans->index);",
			"\t\treturn iterator(&list_dummy);",
			"\t}",
			"\titerator upper_bound(const T& v) {",
			"\t\treturn upper_bound((T&&) v);",
			"\t}",
			"\tRedBlackSet& operator=(const RedBlackSet& R) {",
			"\t\tfor (NODE_LIST* p = list_dummy.fp; p != &list_dummy;) {",
			"\t\t\tp = p->fp;",
			"\t\t\tdelete p->bp;",
			"\t\t}",
			"\t\tnode_dummy.index = &list_dummy;",
			"\t\tnode_dummy.left_size = R.node_dummy.left_size;",
			"\t\tlist_dummy.node = &node_dummy;",
			"\t\tauto dfs = [&](auto f, NODE* old_node, NODE* new_node) {",
			"\t\t\tif (0) return new_node;",
			"\t\t\tif (old_node->left) {",
			"\t\t\t\tnew_node->left = f(f, old_node->left, new NODE((T&&) *(old_node->left->key), new_node));",
			"\t\t\t}",
			"\t\t\tauto l = new NODE_LIST(&list_dummy, true);",
			"\t\t\tl->node = new_node;",
			"\t\t\tnew_node->index = l;",
			"\t\t\tnew_node->red = old_node->red;",
			"\t\t\tnew_node->left_size = old_node->left_size;",
			"\t\t\tnew_node->right_size = old_node->right_size;",
			"\t\t\tif (old_node->right) {",
			"\t\t\t\tnew_node->right = f(f, old_node->right, new NODE((T&&) *(old_node->right->key), new_node));",
			"\t\t\t}",
			"\t\t\treturn new_node;",
			"\t\t};",
			"\t\tif (R.node_dummy.left) node_dummy.left = dfs(dfs, R.node_dummy.left, new NODE((T&&) *(R.node_dummy.left->key), &node_dummy));",
			"\t\treturn *this;",
			"\t}",
			"\tstruct NODE_LIST {",
			"\t\tNODE_LIST* fp;",
			"\t\tNODE_LIST* bp;",
			"\t\tNODE* node;",
			"\t\tbool dummy = false;",
			"\t\tNODE_LIST() : fp(this), bp(this), node(nullptr), dummy(true) {}",
			"\t\tNODE_LIST(NODE_LIST* p, bool is_left) : node(nullptr) {",
			"\t\t\tNODE_LIST* pre = is_left ? p->bp : p;",
			"\t\t\tNODE_LIST* nex = is_left ? p : p->fp;",
			"\t\t\tbp = pre;",
			"\t\t\tfp = nex;",
			"\t\t\tpre->fp = this;",
			"\t\t\tnex->bp = this;",
			"\t\t}",
			"\t\t~NODE_LIST() {",
			"\t\t\tif (!dummy) delete node;",
			"\t\t}",
			"\t\tint get_position() {",
			"\t\t\tint result = -1;",
			"\t\t\tbool is_left = false;",
			"\t\t\tNODE* n = this->node;",
			"\t\t\twhile (true) {",
			"\t\t\t\tif (!is_left) result += n->left_size + 1;",
			"\t\t\t\tif (n->par) is_left = (n->par->left == n);",
			"\t\t\t\telse break;",
			"\t\t\t\tn = n->par;",
			"\t\t\t}",
			"\t\t\treturn result;",
			"\t\t}",
			"\t};",
			"\tvoid remove_list(NODE_LIST* p) {",
			"\t\tp->bp->fp = p->fp;",
			"\t\tp->fp->bp = p->bp;",
			"\t\tdelete p;",
			"\t}",
			"\tstruct NODE {",
			"\t\tT* key;",
			"\t\tNODE_LIST* index;",
			"\t\tNODE* left;",
			"\t\tNODE* right;",
			"\t\tNODE* par;",
			"\t\tbool red = true;",
			"\t\tint left_size;",
			"\t\tint right_size;",
			"\t\tNODE() : key(nullptr), index(nullptr), left(nullptr), right(nullptr), par(nullptr), left_size(0), right_size(0) {}",
			"\t\tNODE(T&& d, NODE* par_) : index(nullptr), left(nullptr) , right(nullptr), par(par_), left_size(0), right_size(0) {",
			"\t\t\tkey = new T(d);",
			"\t\t}",
			"\t\t~NODE() {",
			"\t\t\tdelete key;",
			"\t\t}",
			"\t\tvoid RotateR(NODE*& parent, NODE*& child) {",
			"\t\t\tNODE* P = this;",
			"\t\t\tNODE* R = this->par;",
			"\t\t\tNODE* l = this->left;",
			"\t\t\tNODE* B = l->right;",
			"\t\t\tif (R->left == P) R->left = l;",
			"\t\t\telse R->right = l;",
			"\t\t\tl->par = R;",
			"\t\t\tif (B) B->par = P;",
			"\t\t\tP->left = B;",
			"\t\t\tP->left_size = l->right_size;",
			"\t\t\tl->right_size += P->right_size + 1;",
			"\t\t\tl->right = P;",
			"\t\t\tP->par = l;",
			"\t\t\tparent = R;",
			"\t\t\tchild = l;",
			"\t\t}",
			"\t\tvoid RotateL(NODE*& parent, NODE*& child) {",
			"\t\t\tNODE* P = this;",
			"\t\t\tNODE* R = this->par;",
			"\t\t\tNODE* r = this->right;",
			"\t\t\tNODE* B = r->left;",
			"\t\t\tif (R->left == P) R->left = r;",
			"\t\t\telse R->right = r;",
			"\t\t\tr->par = R;",
			"\t\t\tif (B) B->par = P;",
			"\t\t\tP->right = B;",
			"\t\t\tP->right_size = r->left_size;",
			"\t\t\tr->left_size += P->left_size + 1;",
			"\t\t\tr->left = P;",
			"\t\t\tP->par = r;",
			"\t\t\tparent = R;",
			"\t\t\tchild = r;",
			"\t\t}",
			"\t\tvoid RotateRL(NODE*& parent, NODE*& child) {",
			"\t\t\tthis->right->RotateR(parent, child);",
			"\t\t\tthis->RotateL(parent, child);",
			"\t\t}",
			"\t\tvoid RotateLR(NODE*& parent, NODE*& child) {",
			"\t\t\tthis->left->RotateL(parent, child);",
			"\t\t\tthis->RotateR(parent, child);",
			"\t\t}",
			"\t};",
			"\tvoid remove_node(NODE* n, bool is_left) {",
			"\t\tif (n->par->left == n) n->par->left = is_left ? n->left : n->right;",
			"\t\telse  n->par->right = is_left ? n->left : n->right;",
			"\t\tif (is_left) n->left->par = n->par;",
			"\t\telse n->right->par = n->par;",
			"\t\tremove_list(n->index);",
			"\t}",
			"\tvoid remove_node(NODE* n) {",
			"\t\tif (n->par->left == n) n->par->left = nullptr;",
			"\t\telse  n->par->right = nullptr;",
			"\t\tremove_list(n->index);",
			"\t}",
			"\tvoid insert_run(T&& v, NODE* parent, NODE* child, bool is_left) {",
			"\t\tif (is_left) parent->left = child;",
			"\t\telse parent->right = child;",
			"\t\tchild->index = new NODE_LIST(parent->index, is_left);",
			"\t\tchild->index->node = child;",
			"\t\twhile (parent->red) {",
			"\t\t\tif (parent == &node_dummy) {",
			"\t\t\t\tchild->red = false;",
			"\t\t\t\tbreak;",
			"\t\t\t}",
			"\t\t\tNODE* grand = parent->par;",
			"\t\t\tif (child == parent->left && parent == grand->left) {",
			"\t\t\t\tgrand->RotateR(parent, child);",
			"\t\t\t\tchild->left->red = false;",
			"\t\t\t} else if (child == parent->right && parent == grand->left) {",
			"\t\t\t\tgrand->RotateLR(parent, child);",
			"\t\t\t\tchild->left->red = false;",
			"\t\t\t} else if (child == parent->left && parent == grand->right) {",
			"\t\t\t\tgrand->RotateRL(parent, child);",
			"\t\t\t\tchild->right->red = false;",
			"\t\t\t} else if (child == parent->right && parent == grand->right) {",
			"\t\t\t\tgrand->RotateL(parent, child);",
			"\t\t\t\tchild->right->red = false;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\titerator insert(T&& v) {",
			"\t\tNODE* pre = &node_dummy;",
			"\t\tNODE* now = pre->left;",
			"\t\tbool is_left = true;",
			"\t\tpre->left_size++;",
			"\t\twhile (now != nullptr) {",
			"\t\t\tpre = now;",
			"\t\t\tif (Compare()(*(now->key) , v)) now = now->right, is_left = false, pre->right_size++;",
			"\t\t\telse now = now->left, is_left = true, pre->left_size++;",
			"\t\t}",
			"\t\tNODE* child = new NODE((T&&) v, pre);",
			"\t\tinsert_run((T&&) v, pre, child , is_left);",
			"\t\treturn iterator(child->index);",
			"\t}",
			"\titerator insert(const T& v) {",
			"\t\treturn insert((T&&) v);",
			"\t}",
			"\tvoid erase_run(NODE* target) {",
			"\t\tif (target->red) {",
			"\t\t\tif (target->left) remove_node(target, true);",
			"\t\t\telse if (target->right) remove_node(target, false);",
			"\t\t\telse remove_node(target);",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tNODE* child = target->left ? target->left : target->right;",
			"\t\tNODE* parent;",
			"\t\tbool is_left = target->left == child;",
			"\t\tif (child == nullptr) {",
			"\t\t\tparent = target->par;",
			"\t\t\tis_left = (parent->left == target);",
			"\t\t\tremove_node(target);",
			"\t\t} else if (child->red) {",
			"\t\t\tremove_node(target, is_left);",
			"\t\t\tchild->red = false;",
			"\t\t\treturn;",
			"\t\t} else {",
			"\t\t\tremove_node(target, is_left);",
			"\t\t\tparent = child->par;",
			"\t\t\tis_left = (parent->left == child);",
			"\t\t}",
			"\t\twhile (true) {",
			"\t\t\tNODE *t, *u;",
			"\t\t\tif (parent == &node_dummy) {",
			"\t\t\t\tif (parent->left) parent->left->red = false;",
			"\t\t\t\tbreak;",
			"\t\t\t}",
			"\t\t\tif (is_left) {",
			"\t\t\t\tif (!(parent->right->red)) {",
			"\t\t\t\t\tif (parent->right->left && parent->right->left->red) {",
			"\t\t\t\t\t\tparent->RotateRL(t, u);",
			"\t\t\t\t\t\tparent->par->red = parent->red;",
			"\t\t\t\t\t\tparent->red = false;",
			"\t\t\t\t\t\tbreak;",
			"\t\t\t\t\t} else if (parent->right->right && parent->right->right->red) {",
			"\t\t\t\t\t\tparent->RotateL(t, u);",
			"\t\t\t\t\t\tparent->par->red = parent->red;",
			"\t\t\t\t\t\tparent->red = false;",
			"\t\t\t\t\t\tparent->par->right->red = false;",
			"\t\t\t\t\t\tbreak;",
			"\t\t\t\t\t} else {",
			"\t\t\t\t\t\tparent->right->red = true;",
			"\t\t\t\t\t\tif (parent->red) {",
			"\t\t\t\t\t\t\tparent->red = false;",
			"\t\t\t\t\t\t\tbreak;",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t\tis_left = (parent->par->left == parent);",
			"\t\t\t\t\t\tparent = parent->par;",
			"\t\t\t\t\t}",
			"\t\t\t\t} else {",
			"\t\t\t\t\tparent->RotateL(t, u);",
			"\t\t\t\t\tparent->red = true;",
			"\t\t\t\t\tparent->par->red = false;",
			"\t\t\t\t}",
			"\t\t\t} else /* !is_left */{",
			"\t\t\t\tif (!(parent->left->red)) {",
			"\t\t\t\t\tif (parent->left->right && parent->left->right->red) {",
			"\t\t\t\t\t\tparent->RotateLR(t, u);",
			"\t\t\t\t\t\tparent->par->red = parent->red;",
			"\t\t\t\t\t\tparent->red = false;",
			"\t\t\t\t\t\tbreak;",
			"\t\t\t\t\t} else if (parent->left->left && parent->left->left->red) {",
			"\t\t\t\t\t\tparent->RotateR(t, u);",
			"\t\t\t\t\t\tparent->par->red = parent->red;",
			"\t\t\t\t\t\tparent->red = false;",
			"\t\t\t\t\t\tparent->par->left->red = false;",
			"\t\t\t\t\t\tbreak;",
			"\t\t\t\t\t} else {",
			"\t\t\t\t\t\tparent->left->red = true;",
			"\t\t\t\t\t\tif (parent->red) {",
			"\t\t\t\t\t\t\tparent->red = false;",
			"\t\t\t\t\t\t\tbreak;",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t\tis_left = (parent->par->left == parent);",
			"\t\t\t\t\t\tparent = parent->par;",
			"\t\t\t\t\t}",
			"\t\t\t\t} else {",
			"\t\t\t\t\tparent->RotateR(t, u);",
			"\t\t\t\t\tparent->red = true;",
			"\t\t\t\t\tparent->par->red = false;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t} /* while true */",
			"\t}",
			"\titerator erase(T&& v) {",
			"\t\tNODE* pre = &node_dummy;",
			"\t\tNODE* now = pre->left;",
			"\t\tqueue<pair<bool, NODE*>> q;",
			"\t\tq.emplace(true, pre);",
			"\t\tNODE* target = nullptr;",
			"\t\twhile (now != nullptr) {",
			"\t\t\tpre = now;",
			"\t\t\tif (Compare()(*(now->key) , v)) now = now->right, q.emplace(false, pre);",
			"\t\t\telse if (Compare()(v, *(now->key))) now = now->left, q.emplace(true, pre);",
			"\t\t\telse break;",
			"\t\t}",
			"\t\tif (now == nullptr) return iterator(&list_dummy);",
			"\t\ttarget = now;",
			"\t\twhile (!q.empty()) {",
			"\t\t\tif (q.front().first) q.front().second->left_size--;",
			"\t\t\telse q.front().second->right_size--;",
			"\t\t\tq.pop();",
			"\t\t}",
			"\t\tif (target->left != nullptr) {",
			"\t\t\ttarget->left_size--;",
			"\t\t\ttarget = target->left;",
			"\t\t\twhile (target->right) target->right_size--, target = target->right;",
			"\t\t}",
			"\t\tswap(now->key, target->key);",
			"\t\tNODE* t = target->index->fp->node;",
			"\t\terase_run(target);",
			"\t\treturn iterator(t->index);",
			"\t}",
			"\titerator erase(const T& v) {",
			"\t\treturn erase((T&&) v);",
			"\t}",
			"\tint count(T&& v) {",
			"\t\tenum STATUS {LEFT, RIGHT, NEUTRAL};",
			"\t\tint sum = 0;",
			"\t\tqueue<pair<STATUS, NODE*>> q;",
			"\t\tq.emplace(NEUTRAL, node_dummy.left);",
			"\t\twhile (!q.empty()) {",
			"\t\t\tpair<STATUS, NODE*> t = q.front();",
			"\t\t\tq.pop();",
			"\t\t\tint status = t.first;",
			"\t\t\tNODE* n = t.second;",
			"\t\t\tif (n == nullptr) continue;",
			"\t\t\tif (status == NEUTRAL) {",
			"\t\t\t\tif (Compare()(v, *(n->key))) q.emplace(NEUTRAL, n->left);",
			"\t\t\t\telse if (Compare()(*(n->key), v)) q.emplace(NEUTRAL, n->right);",
			"\t\t\t\telse {",
			"\t\t\t\t\tsum++;",
			"\t\t\t\t\tq.emplace(LEFT, n->left);",
			"\t\t\t\t\tq.emplace(RIGHT, n->right);",
			"\t\t\t\t}",
			"\t\t\t} else if (status == LEFT) {",
			"\t\t\t\tif (Compare()(*(n->key), v)) q.emplace(LEFT, n->right);",
			"\t\t\t\telse {",
			"\t\t\t\t\tsum += n->right_size + 1;",
			"\t\t\t\t\tq.emplace(LEFT, n->left);",
			"\t\t\t\t}",
			"\t\t\t} else /* if (status == RIGHT) */{",
			"\t\t\t\tif (Compare()(v, *(n->key))) q.emplace(RIGHT, n->left);",
			"\t\t\t\telse {",
			"\t\t\t\t\tsum += n->left_size + 1;",
			"\t\t\t\t\tq.emplace(RIGHT, n->right);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn sum;",
			"\t}",
			"\tint count(const T& v) {",
			"\t\treturn count((T&&) v);",
			"\t}",
			"\tbool is_balanced() {",
			"\t\tauto dfs = [&](auto f, NODE* R, int& black, int& cnt, bool is_red = true) {",
			"\t\t\tif (is_red && R->red) return false;",
			"\t\t\tint r_black = 0;",
			"\t\t\tint l_black = 0;",
			"\t\t\tint r_cnt = 0;",
			"\t\t\tint l_cnt = 0;",
			"\t\t\tcnt = 1;",
			"\t\t\tif (R->left) {",
			"\t\t\t\tif (!f(f, R->left, l_black, l_cnt, R->red)) return false;",
			"\t\t\t}",
			"\t\t\tif (R->right) {",
			"\t\t\t\tif (!f(f, R->right, r_black, r_cnt, R->red)) return false;",
			"\t\t\t}",
			"\t\t\tif (r_black != l_black) {",
			"\t\t\t\tcerr << \"black\" << endl;",
			"\t\t\t\treturn false;",
			"\t\t\t}",
			"\t\t\tif (r_cnt != R->right_size) {",
			"\t\t\t\tcerr << \"r_cnt\" << endl;",
			"\t\t\t\treturn false;",
			"\t\t\t}",
			"\t\t\tif (l_cnt != R->left_size) {",
			"\t\t\t\tcerr << \"l_cnt\" << endl;",
			"\t\t\t\treturn false;",
			"\t\t\t}",
			"\t\t\tblack = r_black + !(R->red);",
			"\t\t\tcnt += r_cnt + l_cnt;",
			"\t\t\treturn true;",
			"\t\t};",
			"\t\tint t, u;",
			"\t\treturn dfs(dfs, node_dummy.left, t, u);",
			"\t}",
			"\tconst T& operator[](int x) {",
			"\t\tif (x < 0 || size() <= x) throw out_of_range(\"Error at RedBlackSet::operator[]\");",
			"\t\tint pos = 0;",
			"\t\tNODE* now = node_dummy.left;",
			"\t\twhile (true) {",
			"\t\t\tif (pos + now->left_size < x) pos += now->left_size + 1, now = now->right;",
			"\t\t\telse if (x < pos + now->left_size) now = now->left;",
			"\t\t\telse break;",
			"\t\t}",
			"\t\treturn *(now->key);",
			"\t}",
			"};",
			"template<class T>",
			"class RedBlackSetIterator {",
			"\tfriend RedBlackSet<T>;",
			"\tusing NODE_LIST = typename RedBlackSet<T>::NODE_LIST;",
			"\tNODE_LIST* list_ptr;",
			"\tRedBlackSetIterator(NODE_LIST* n) : list_ptr(n) {}",
			"public:",
			"\tRedBlackSetIterator(const RedBlackSetIterator& R) : list_ptr(R.list_ptr) {}",
			"\tRedBlackSetIterator& operator++() {",
			"\t\tif (list_ptr->dummy) throw out_of_range(\"Error at RedBlackSetIterator& operator++()\");",
			"\t\tlist_ptr = list_ptr->fp;",
			"\t\treturn *this;",
			"\t}",
			"\tRedBlackSetIterator operator++(int unused) {",
			"\t\tif (list_ptr->dummy) throw out_of_range(\"Error at RedBlackSetIterator operator++(int)\");",
			"\t\tRedBlackSetIterator result = *this;",
			"\t\tlist_ptr = list_ptr->fp;",
			"\t\treturn result;",
			"\t}",
			"\tRedBlackSetIterator& operator--() {",
			"\t\tif (list_ptr->bp->dummy) throw out_of_range(\"Error at RedBlackSetIterator& operator--()\");",
			"\t\tlist_ptr = list_ptr->bp;",
			"\t\treturn *this;",
			"\t}",
			"\tRedBlackSetIterator operator--(int unused) {",
			"\t\tif (list_ptr->bp->dummy) throw out_of_range(\"Error at RedBlackSetIterator operator--(int)\");",
			"\t\tRedBlackSetIterator result = *this;",
			"\t\tlist_ptr = list_ptr->bp;",
			"\t\treturn result;",
			"\t}",
			"\tint operator-(const RedBlackSetIterator& R) {",
			"\t\treturn list_ptr->get_position() - R.list_ptr->get_position();",
			"\t}",
			"\tconst T& operator*() const {",
			"\t\tassert(list_ptr->node->key);",
			"\t\treturn *(list_ptr->node->key);",
			"\t}",
			"\tbool operator==(const RedBlackSetIterator& R) {",
			"\t\treturn this->list_ptr == R.list_ptr;",
			"\t}",
			"\tbool operator!=(const RedBlackSetIterator& R) {",
			"\t\treturn !(*this == R);",
			"\t}",
			"};",
			"}",
			"",
			"using namespace spihill;",
			"",
			"void check_insert(const int);",
			"void check_erase(const int);",
			"bool check(RedBlackSet<int>& R, multiset<int>& S);",
			"",
			"int main()",
			"{",
			"\tcout << \"START INSERT TEST\" << endl;",
			"\tcheck_insert(100000);",
			"\tcout << \"PASSED\" << endl;",
			"\tcout << \"START ERASE TEST\" << endl;",
			"\tcheck_erase(100000);",
			"\tcout << \"PASSED\" << endl;",
			"\treturn 0;",
			"}",
			"",
			"void check_erase(const int MAX)",
			"{",
			"\tRedBlackSet<int> R_random_small;",
			"\tRedBlackSet<int> R_increase;",
			"\tRedBlackSet<int> R_decrease;",
			"\tRedBlackSet<int> R_nothing;",
			"",
			"\tmultiset<int> S_random_small;",
			"\tmultiset<int> S_increase;",
			"\tmultiset<int> S_decrease;",
			"\tmultiset<int> S_nothing;",
			"",
			"\tstd::random_device seed_gen;",
			"\tstd::mt19937 engine(seed_gen());",
			"",
			"\tstd::uniform_real_distribution<> dist1(-1.0, 1.0);",
			"",
			"\tfor (int i = -MAX; i < MAX; i++) {",
			"\t\tint big = 1000000000 * dist1(engine);",
			"\t\tint small = 100 * dist1(engine);",
			"\t\tR_random_small.insert(small);",
			"\t\tR_increase.insert(i);",
			"\t\tR_decrease.insert(i);",
			"\t\tR_nothing.insert(big);",
			"\t\tS_random_small.insert(small);",
			"\t\tS_increase.insert(i);",
			"\t\tS_decrease.insert(i);",
			"\t}",
			"\tfor (int i = 0; i < MAX; i++) {",
			"\t\tR_increase.erase(-i - 1);",
			"\t\tR_decrease.erase(i);",
			"\t\tS_increase.erase(-i - 1);",
			"\t\tS_decrease.erase(i);",
			"\t}",
			"",
			"\tfor (int i = -100; i <= 100; i++) {",
			"\t\tassert(R_random_small.count(i) == (int) S_random_small.count(i));",
			"\t\tassert((int) S_random_small.count(i) == R_random_small.upper_bound(i) - R_random_small.lower_bound(i));",
			"\t}",
			"",
			"\tfor (int i = 0; i < 10; i++) {",
			"\t\tint small = 100 * dist1(engine);",
			"\t\twhile (R_random_small.erase(small) != R_random_small.end());",
			"\t\tS_random_small.erase(small);",
			"\t}",
			"",
			"\tfor (int i = -100; i <= 100; i++) {",
			"\t\tassert(R_random_small.count(i) == (int) S_random_small.count(i));",
			"\t\tassert((int) S_random_small.count(i) == R_random_small.upper_bound(i) - R_random_small.lower_bound(i));",
			"\t}",
			"",
			"\twhile (R_nothing.erase(*(R_nothing.begin())) != R_nothing.end());",
			"",
			"\tassert(check(R_increase, S_increase));",
			"\tassert(check(R_decrease, S_decrease));",
			"\tassert(check(R_random_small, S_random_small));",
			"\tassert(check(R_nothing, S_nothing));",
			"\tassert(R_increase.is_balanced());",
			"\tassert(R_decrease.is_balanced());",
			"\tassert(R_random_small.is_balanced());",
			"\treturn;",
			"}",
			"",
			"void check_insert(const int MAX)",
			"{",
			"\tRedBlackSet<int> R_random_big;",
			"\tRedBlackSet<int> R_random_small;",
			"\tRedBlackSet<int> R_increase;",
			"\tRedBlackSet<int> R_decrease;",
			"",
			"\tmultiset<int> S_random_big;",
			"\tmultiset<int> S_random_small;",
			"\tmultiset<int> S_increase;",
			"\tmultiset<int> S_decrease;",
			"",
			"\tstd::random_device seed_gen;",
			"\tstd::mt19937 engine(seed_gen());",
			"",
			"\tstd::uniform_real_distribution<> dist1(-1.0, 1.0);",
			"",
			"\tfor (int i = -MAX; i < MAX; i++) {",
			"\t\tint big = 1000000000 * dist1(engine);",
			"\t\tint small = 100 * dist1(engine);",
			"\t\tR_random_big.insert(big);",
			"\t\tR_random_small.insert(small);",
			"\t\tR_increase.insert(i);",
			"\t\tR_decrease.insert(-i);",
			"\t\tS_random_big.insert(big);",
			"\t\tS_random_small.insert(small);",
			"\t\tS_increase.insert(i);",
			"\t\tS_decrease.insert(-i);",
			"\t}",
			"\tauto R_copy(R_random_big);",
			"\tauto S_copy = S_random_big;",
			"\tRedBlackSet<int> R_assign;",
			"\tR_assign = R_random_big;",
			"\tfor (int i = -MAX; i < MAX; i++) {",
			"\t\tint big = 1000000000 * dist1(engine);",
			"\t\tR_copy.insert(big);",
			"\t\tR_assign.insert(big);",
			"\t\tS_copy.insert(big);",
			"\t}",
			"\tassert(check(R_increase, S_increase));",
			"\tassert(check(R_decrease, S_decrease));",
			"\tassert(check(R_random_big, S_random_big));",
			"\tassert(check(R_random_small, S_random_small));",
			"\tassert(check(R_copy, S_copy));",
			"\tassert(check(R_assign, S_copy));",
			"\tassert(R_increase.is_balanced());",
			"\tassert(R_decrease.is_balanced());",
			"\tassert(R_random_big.is_balanced());",
			"\tassert(R_copy.is_balanced());",
			"\tassert(R_assign.is_balanced());",
			"\tassert(R_random_small.is_balanced());",
			"\treturn;",
			"}",
			"",
			"bool check(RedBlackSet<int>& R, multiset<int>& S)",
			"{",
			"\tauto itr_S = S.begin();",
			"\tauto itr_R = R.begin();",
			"\tif ((int) S.size() != R.size()) {",
			"\t\tcerr << \"S.size() != R.size()\" << endl;",
			"\t\treturn false;",
			"\t}",
			"\tfor (; itr_R != R.end(); itr_R++, itr_S++) {",
			"\t\tif (*itr_R != *itr_S) return false;",
			"\t}",
			"\treturn itr_S == S.end();",
			"}"
		]
	},
	"AVLSet": {
		"prefix": "AVLSet",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"using namespace std;",
			"",
			"namespace spihill {",
			"template<class T>",
			"class AVLSetIterator;",
			"",
			"template<class T, class Compare = less<T>>",
			"struct AVLSet {",
			"\tstruct NODE;",
			"\tstruct NODE_LIST;",
			"\tNODE_LIST list_dummy;",
			"\tNODE node_dummy;",
			"\tfriend AVLSetIterator<T>;",
			"\tusing iterator = AVLSetIterator<T>;",
			"\tAVLSet() {",
			"\t\tnode_dummy.index = &list_dummy;",
			"\t\tlist_dummy.node = &node_dummy;",
			"\t}",
			"\tAVLSet(const AVLSet& R) {",
			"\t\tnode_dummy.index = &list_dummy;",
			"\t\tlist_dummy.node = &node_dummy;",
			"\t\tauto dfs = [&](auto f, NODE* old_node, NODE* new_node) {",
			"\t\t\tif (0) return new_node;",
			"\t\t\tif (old_node->left) {",
			"\t\t\t\tnew_node->left = f(f, old_node->left, new NODE((T&&) *(old_node->left->key), new_node));",
			"\t\t\t}",
			"\t\t\tauto l = new NODE_LIST(&list_dummy, true);",
			"\t\t\tl->node = new_node;",
			"\t\t\tnew_node->index = l;",
			"\t\t\tnew_node->child_size = old_node->child_size;",
			"\t\t\tnew_node->height = old_node->height;",
			"\t\t\tif (old_node->right) {",
			"\t\t\t\tnew_node->right = f(f, old_node->right, new NODE((T&&) *(old_node->right->key), new_node));",
			"\t\t\t}",
			"\t\t\treturn new_node;",
			"\t\t};",
			"\t\tif (R.node_dummy.left) node_dummy.left = dfs(dfs, R.node_dummy.left, new NODE((T&&) *(R.node_dummy.left->key), &node_dummy));",
			"\t}",
			"\tAVLSet& operator=(const AVLSet& R) {",
			"\t\tfor (NODE_LIST* p = list_dummy.fp; p != &list_dummy;) {",
			"\t\t\tp = p->fp;",
			"\t\t\tdelete p->bp;",
			"\t\t}",
			"\t\tnode_dummy.index = &list_dummy;",
			"\t\tlist_dummy.node = &node_dummy;",
			"\t\tauto dfs = [&](auto f, NODE* old_node, NODE* new_node) {",
			"\t\t\tif (0) return new_node;",
			"\t\t\tif (old_node->left) {",
			"\t\t\t\tnew_node->left = f(f, old_node->left, new NODE((T&&) *(old_node->left->key), new_node));",
			"\t\t\t}",
			"\t\t\tauto l = new NODE_LIST(&list_dummy, true);",
			"\t\t\tl->node = new_node;",
			"\t\t\tnew_node->index = l;",
			"\t\t\tnew_node->child_size = old_node->child_size;",
			"\t\t\tnew_node->height = old_node->height;",
			"\t\t\tif (old_node->right) {",
			"\t\t\t\tnew_node->right = f(f, old_node->right, new NODE((T&&) *(old_node->right->key), new_node));",
			"\t\t\t}",
			"\t\t\treturn new_node;",
			"\t\t};",
			"\t\tif (R.node_dummy.left) node_dummy.left = dfs(dfs, R.node_dummy.left, new NODE((T&&) *(R.node_dummy.left->key), &node_dummy));",
			"\t\treturn *this;",
			"\t}",
			"\t~AVLSet() {",
			"\t\tfor (NODE_LIST* p = list_dummy.fp; p != &list_dummy;) {",
			"\t\t\tp = p->fp;",
			"\t\t\tdelete p->bp;",
			"\t\t}",
			"\t}",
			"\tint size() {",
			"\t\tif (node_dummy.left) return node_dummy.left->child_size;",
			"\t\treturn 0;",
			"\t}",
			"\tstruct NODE_LIST {",
			"\t\tNODE_LIST* fp;",
			"\t\tNODE_LIST* bp;",
			"\t\tNODE* node;",
			"\t\tbool dummy = false;",
			"\t\tNODE_LIST() : fp(this), bp(this), node(nullptr), dummy(true) {}",
			"\t\tNODE_LIST(NODE_LIST* p, bool is_left) : node(nullptr) {",
			"\t\t\tNODE_LIST* pre = is_left ? p->bp : p;",
			"\t\t\tNODE_LIST* nex = is_left ? p : p->fp;",
			"\t\t\tbp = pre;",
			"\t\t\tfp = nex;",
			"\t\t\tpre->fp = this;",
			"\t\t\tnex->bp = this;",
			"\t\t}",
			"\t\t~NODE_LIST() {",
			"\t\t\tif (!dummy) delete node;",
			"\t\t}",
			"\t\tint get_position() {",
			"\t\t\tint result = -1;",
			"\t\t\tbool is_left = false;",
			"\t\t\tNODE* n = node;",
			"\t\t\tfor (;; n = n->par) {",
			"\t\t\t\tif (!is_left) result += n->left ? n->left->child_size + 1 : 1;",
			"\t\t\t\tif (n->par) is_left = (n->par->left == n);",
			"\t\t\t\telse break;",
			"\t\t\t}",
			"\t\t\treturn result;",
			"\t\t}",
			"\t};",
			"\tvoid remove_list(NODE_LIST* p) {",
			"\t\tp->bp->fp = p->fp;",
			"\t\tp->fp->bp = p->bp;",
			"\t\tdelete p;",
			"\t}",
			"\tvoid remove_node(NODE* n, bool is_left) {",
			"\t\tif (n->par->left == n) n->par->left = is_left ? n->left : n->right;",
			"\t\telse  n->par->right = is_left ? n->left : n->right;",
			"\t\tif (is_left) n->left->par = n->par;",
			"\t\telse n->right->par = n->par;",
			"\t\tfor (NODE* i = n->par; i != &node_dummy; i = i->par) i->child_size--;",
			"\t\tremove_list(n->index);",
			"\t}",
			"\tvoid remove_node(NODE* n) {",
			"\t\tif (n->par->left == n) n->par->left = nullptr;",
			"\t\telse  n->par->right = nullptr;",
			"\t\tfor (NODE* i = n->par; i != &node_dummy; i = i->par) i->child_size--;",
			"\t\tremove_list(n->index);",
			"\t}",
			"\tstruct NODE {",
			"\t\tT* key;",
			"\t\tNODE_LIST* index;",
			"\t\tNODE* left;",
			"\t\tNODE* right;",
			"\t\tNODE* par;",
			"\t\tint child_size;",
			"\t\tint height;",
			"\t\tNODE() : key(nullptr), index(nullptr), left(nullptr), right(nullptr), par(nullptr), child_size(0), height(0) {}",
			"\t\tNODE(T&& d, NODE* par_) : index(nullptr), left(nullptr) , right(nullptr), par(par_), child_size(1), height(1) {key = new T(d);}",
			"\t\t~NODE() {delete key;}",
			"\t\tvoid RotateR() {",
			"\t\t\tNODE* P = this;",
			"\t\t\tNODE* R = this->par;",
			"\t\t\tNODE* l = this->left;",
			"\t\t\tNODE* B = l->right;",
			"\t\t\tif (R->left == P) R->left = l;",
			"\t\t\telse R->right = l;",
			"\t\t\tl->par = R;",
			"\t\t\tif (B) B->par = P;",
			"\t\t\tP->left = B;",
			"\t\t\tl->right = P;",
			"\t\t\tP->par = l;",
			"\t\t\tint B_size = B ? B->child_size : 0;",
			"\t\t\tP->child_size += B_size - l->child_size;",
			"\t\t\tl->child_size += P->child_size - B_size;",
			"\t\t\tP->update_height();",
			"\t\t\tl->update_height();",
			"\t\t}",
			"\t\tvoid RotateL() {",
			"\t\t\tNODE* P = this;",
			"\t\t\tNODE* R = this->par;",
			"\t\t\tNODE* r = this->right;",
			"\t\t\tNODE* B = r->left;",
			"\t\t\tif (R->left == P) R->left = r;",
			"\t\t\telse R->right = r;",
			"\t\t\tr->par = R;",
			"\t\t\tif (B) B->par = P;",
			"\t\t\tP->right = B;",
			"\t\t\tr->left = P;",
			"\t\t\tP->par = r;",
			"\t\t\tint B_size = B ? B->child_size : 0;",
			"\t\t\tP->child_size += B_size - r->child_size;",
			"\t\t\tr->child_size += P->child_size - B_size;",
			"\t\t\tP->update_height();",
			"\t\t\tr->update_height();",
			"\t\t}",
			"\t\tvoid RotateRL() {",
			"\t\t\tright->RotateR();",
			"\t\t\tRotateL();",
			"\t\t}",
			"\t\tvoid RotateLR() {",
			"\t\t\tleft->RotateL();",
			"\t\t\tRotateR();",
			"\t\t}",
			"\t\tint bias() {",
			"\t\t\tint L = left  ? left->height  : 0;",
			"\t\t\tint R = right ? right->height : 0;",
			"\t\t\treturn L - R;",
			"\t\t}",
			"\t\tvoid update_height() {",
			"\t\t\tint L = left  ? left->height  : 0;",
			"\t\t\tint R = right ? right->height : 0;",
			"\t\t\theight = max(L, R) + 1;",
			"\t\t}",
			"\t};",
			"\tvoid balancing_insert(NODE* parent) {",
			"\t\tfor (;!(parent->index->dummy); parent = parent->par) {",
			"\t\t\tparent->update_height();",
			"\t\t\tif (parent->bias() == 0) return;",
			"\t\t\tif (abs(parent->bias()) != 1) break;",
			"\t\t}",
			"\t\tif (parent != &node_dummy) balancing_rotate(parent);",
			"\t}",
			"\tvoid balancing_erase(NODE* parent) {",
			"\t\tfor (;; parent = parent->par->par) {",
			"\t\t\tfor (;!(parent->index->dummy); parent = parent->par) {",
			"\t\t\t\tparent->update_height();",
			"\t\t\t\tif (abs(parent->bias()) == 1) return;",
			"\t\t\t\tif (parent->bias() != 0) break;",
			"\t\t\t}",
			"\t\t\tif (parent == &node_dummy) return;",
			"\t\t\tbalancing_rotate(parent);",
			"\t\t}",
			"\t}",
			"\tvoid balancing_rotate(NODE* parent) {",
			"\t\tif (parent->bias() == 2) {",
			"\t\t\tif (parent->left->bias() == -1) parent->RotateLR();",
			"\t\t\telse parent->RotateR();",
			"\t\t} else {",
			"\t\t\tif (parent->right->bias() == 1) parent->RotateRL();",
			"\t\t\telse parent->RotateL();",
			"\t\t}",
			"\t}",
			"\titerator erase(T&& k) {",
			"\t\tNODE* now = node_dummy.left;",
			"\t\twhile (now) {",
			"\t\t\tif (Compare()(k, *(now->key))) now = now->left;",
			"\t\t\telse if (Compare()(*(now->key), k)) now = now->right;",
			"\t\t\telse break;",
			"\t\t}",
			"\t\tif (now == nullptr) return iterator(&list_dummy);",
			"\t\tNODE* target;",
			"\t\tif (now->left) target = now->index->bp->node;",
			"\t\telse target = now;",
			"\t\tassert(target->child_size <= 2);",
			"\t\tNODE_LIST* res = now->index->fp;",
			"\t\tswap(now->key, target->key);",
			"\t\tnow = target->par;",
			"\t\tbool is_left = (now->left == target);",
			"\t\tif (target->left) remove_node(target, true);",
			"\t\telse if (target->right) remove_node(target, false);",
			"\t\telse remove_node(target);",
			"\t\tbalancing_erase(now);",
			"\t\treturn iterator(res);",
			"\t}",
			"\titerator erase(const T& k) {",
			"\t\treturn erase((T&&) k);",
			"\t}",
			"\titerator insert(T&& k) {",
			"\t\tNODE* parent = &node_dummy;",
			"\t\tNODE* now = parent->left;",
			"\t\tbool is_left = true;",
			"\t\twhile (now) {",
			"\t\t\tparent = now;",
			"\t\t\tnow->child_size++;",
			"\t\t\tif (is_left = Compare()(k, *(now->key))) now = now->left;",
			"\t\t\telse now = now->right;",
			"\t\t}",
			"\t\tNODE* child = new NODE((T&&) k, parent);",
			"\t\tif (is_left) parent->left = child;",
			"\t\telse parent->right = child;",
			"\t\tchild->index = new NODE_LIST(parent->index, is_left);",
			"\t\tchild->index->node = child;",
			"\t\tbalancing_insert(parent);",
			"\t\treturn iterator(child->index);",
			"\t}",
			"\titerator insert(const T& k) {",
			"\t\treturn insert((T&&) k);",
			"\t}",
			"\tint count(T&& v) {",
			"\t\tenum STATUS {LEFT, RIGHT, NEUTRAL};",
			"\t\tint sum = 0;",
			"\t\tqueue<pair<STATUS, NODE*>> q;",
			"\t\tq.emplace(NEUTRAL, node_dummy.left);",
			"\t\twhile (!q.empty()) {",
			"\t\t\tpair<STATUS, NODE*> t = q.front();",
			"\t\t\tq.pop();",
			"\t\t\tint status = t.first;",
			"\t\t\tNODE* n = t.second;",
			"\t\t\tif (n == nullptr) continue;",
			"\t\t\tif (status == NEUTRAL) {",
			"\t\t\t\tif (Compare()(v, *(n->key))) q.emplace(NEUTRAL, n->left);",
			"\t\t\t\telse if (Compare()(*(n->key), v)) q.emplace(NEUTRAL, n->right);",
			"\t\t\t\telse {",
			"\t\t\t\t\tsum++;",
			"\t\t\t\t\tq.emplace(LEFT, n->left);",
			"\t\t\t\t\tq.emplace(RIGHT, n->right);",
			"\t\t\t\t}",
			"\t\t\t} else if (status == LEFT) {",
			"\t\t\t\tif (Compare()(*(n->key), v)) q.emplace(LEFT, n->right);",
			"\t\t\t\telse {",
			"\t\t\t\t\tsum += (n->right ? n->right->child_size : 0) + 1;",
			"\t\t\t\t\tq.emplace(LEFT, n->left);",
			"\t\t\t\t}",
			"\t\t\t} else /* if (status == RIGHT) */{",
			"\t\t\t\tif (Compare()(v, *(n->key))) q.emplace(RIGHT, n->left);",
			"\t\t\t\telse {",
			"\t\t\t\t\tsum += (n->left ? n->left->child_size : 0) + 1;",
			"\t\t\t\t\tq.emplace(RIGHT, n->right);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn sum;",
			"\t}",
			"\tint count(const T& v) {",
			"\t\treturn count((T&&) v);",
			"\t}",
			"\tbool is_balanced() {",
			"\t\tauto dfs = [&](auto f, NODE* n, int& height, int& c_size) {",
			"\t\t\tif (0) return false;",
			"\t\t\tif (n == nullptr) {",
			"\t\t\t\theight = 0;",
			"\t\t\t\tc_size = 0;",
			"\t\t\t\treturn true;",
			"\t\t\t}",
			"\t\t\tint L = 0, R = 0;",
			"\t\t\tc_size = 1;",
			"\t\t\tint t;",
			"\t\t\tif (!f(f, n->left, L, t)) return false;",
			"\t\t\tc_size += t;",
			"\t\t\tif (!f(f, n->right, R, t)) return false;",
			"\t\t\tc_size += t;",
			"\t\t\theight = max(L, R) + 1;",
			"\t\t\tif (n->height != height) {",
			"\t\t\t\tcerr << \"hight value is odd.\" << endl;",
			"\t\t\t\treturn false;",
			"\t\t\t}",
			"\t\t\tif (n->bias() < -2 || n->bias() > 2) {",
			"\t\t\t\tcerr << \"bias value is odd.\" << endl;",
			"\t\t\t\tcerr << \"bias : \" << n->bias() << endl;",
			"\t\t\t\treturn false;",
			"\t\t\t}",
			"\t\t\tif (c_size != n->child_size) {",
			"\t\t\t\tcerr << \"child_size is wrong\" << endl;",
			"\t\t\t\tcerr << \"size : \" << n->child_size << endl;",
			"\t\t\t\tcerr << \"real : \" << c_size << endl;",
			"\t\t\t\treturn false;",
			"\t\t\t}",
			"\t\t\theight = std::max(L, R) + 1;",
			"\t\t\treturn true;",
			"\t\t};",
			"\t\tint t, u;",
			"\t\treturn dfs(dfs, node_dummy.left, t, u);",
			"\t}",
			"\titerator begin() {",
			"\t\treturn iterator(list_dummy.fp);",
			"\t}",
			"\titerator end() {",
			"\t\treturn iterator(&list_dummy);",
			"\t}",
			"\titerator lower_bound(T&& v) {",
			"\t\tNODE* now = node_dummy.left;",
			"\t\tNODE* ans = nullptr;",
			"\t\twhile (now != nullptr) {",
			"\t\t\tif (Compare()(*(now->key), v)) {",
			"\t\t\t\tnow = now->right;",
			"\t\t\t}",
			"\t\t\telse {",
			"\t\t\t\tans = now;",
			"\t\t\t\tnow = now->left;",
			"\t\t\t}",
			"\t\t}",
			"\t\tif (ans) return iterator(ans->index);",
			"\t\treturn iterator(&list_dummy);",
			"\t}",
			"\titerator lower_bound(const T& v) {",
			"\t\treturn lower_bound((T&&) v);",
			"\t}",
			"\titerator upper_bound(T&& v) {",
			"\t\tNODE* now = node_dummy.left;",
			"\t\tNODE* ans = nullptr;",
			"\t\twhile (now != nullptr) {",
			"\t\t\tif (Compare()(v, *(now->key))) {",
			"\t\t\t\tans = now;",
			"\t\t\t\tnow = now->left;",
			"\t\t\t}",
			"\t\t\telse {",
			"\t\t\t\tnow = now->right;",
			"\t\t\t}",
			"\t\t}",
			"\t\tif (ans) return iterator(ans->index);",
			"\t\treturn iterator(&list_dummy);",
			"\t}",
			"\titerator upper_bound(const T& v) {",
			"\t\treturn upper_bound((T&&) v);",
			"\t}",
			"\tconst T& get_kth_element(int k) {",
			"\t\tif (k < 0 || size() <= k) throw out_of_range(\"Error at AVLSet::get_kth_element(int)\");",
			"\t\tint pos = 0;",
			"\t\tNODE* now = node_dummy.left;",
			"\t\twhile (true) {",
			"\t\t\tint L = now->left ? now->left->child_size : 0;",
			"\t\t\tif (Compare()(pos + L, k)) pos += L + 1, now = now->right;",
			"\t\t\telse if (Compare()(k, L + pos)) now = now->left;",
			"\t\t\telse break;",
			"\t\t}",
			"\t\treturn *(now->key);",
			"\t}",
			"};",
			"template<class T>",
			"class AVLSetIterator {",
			"\tfriend AVLSet<T>;",
			"\tusing NODE_LIST = typename AVLSet<T>::NODE_LIST;",
			"\tNODE_LIST* list_ptr;",
			"\tAVLSetIterator(NODE_LIST* n) : list_ptr(n) {}",
			"public:",
			"\tAVLSetIterator(const AVLSetIterator& R) : list_ptr(R.list_ptr) {}",
			"\tAVLSetIterator& operator++() {",
			"\t\tif (list_ptr->dummy) throw out_of_range(\"Error at AVLSetIterator& operator++()\");",
			"\t\tlist_ptr = list_ptr->fp;",
			"\t\treturn *this;",
			"\t}",
			"\tAVLSetIterator operator++(int unused) {",
			"\t\tif (list_ptr->dummy) throw out_of_range(\"Error at AVLSetIterator operator++(int)\");",
			"\t\tAVLSetIterator result = *this;",
			"\t\tlist_ptr = list_ptr->fp;",
			"\t\treturn result;",
			"\t}",
			"\tAVLSetIterator& operator--() {",
			"\t\tif (list_ptr->bp->dummy) throw out_of_range(\"Error at AVLSetIterator& operator--()\");",
			"\t\tlist_ptr = list_ptr->bp;",
			"\t\treturn *this;",
			"\t}",
			"\tAVLSetIterator operator--(int unused) {",
			"\t\tif (list_ptr->bp->dummy) throw out_of_range(\"Error at AVLSetIterator operator--(int)\");",
			"\t\tAVLSetIterator result = *this;",
			"\t\tlist_ptr = list_ptr->bp;",
			"\t\treturn result;",
			"\t}",
			"\tint operator-(const AVLSetIterator& R) {",
			"\t\treturn list_ptr->get_position() - R.list_ptr->get_position();",
			"\t}",
			"\tconst T& operator*() const {",
			"\t\tassert(list_ptr->node->key);",
			"\t\treturn *(list_ptr->node->key);",
			"\t}",
			"\tbool operator==(const AVLSetIterator& R) {",
			"\t\treturn this->list_ptr == R.list_ptr;",
			"\t}",
			"\tbool operator!=(const AVLSetIterator& R) {",
			"\t\treturn !(*this == R);",
			"\t}",
			"};",
			"} // namespace",
			"",
			"using namespace spihill;",
			"",
			"void check_insert(const int);",
			"void check_erase(const int);",
			"bool check(AVLSet<int>& R, multiset<int>& S);",
			"",
			"int main()",
			"{",
			"\tcout << \"INSERT TEST\" << endl;",
			"\tcheck_insert(100000);",
			"\tcout << \"TEST PASSED\" << endl;",
			"\tcout << \"ERASE TEST\" << endl;",
			"\tcheck_erase(100000);",
			"\tcout << \"TEST PASSED\" << endl;",
			"}",
			"",
			"void check_insert(const int MAX)",
			"{",
			"\tAVLSet<int> R_random_big;",
			"\tAVLSet<int> R_random_small;",
			"\tAVLSet<int> R_increase;",
			"\tAVLSet<int> R_decrease;",
			"",
			"\tmultiset<int> S_random_big;",
			"\tmultiset<int> S_random_small;",
			"\tmultiset<int> S_increase;",
			"\tmultiset<int> S_decrease;",
			"",
			"\tstd::random_device seed_gen;",
			"\tstd::mt19937 engine(seed_gen());",
			"",
			"\tstd::uniform_real_distribution<> dist1(-1.0, 1.0);",
			"",
			"\tfor (int i = -MAX; i < MAX; i++) {",
			"\t\tint big = 1000000000 * dist1(engine);",
			"\t\tint small = 100 * dist1(engine);",
			"\t\tR_random_big.insert(big);",
			"\t\tR_random_small.insert(small);",
			"\t\tR_increase.insert(i);",
			"\t\tR_decrease.insert(-i);",
			"\t\tS_random_big.insert(big);",
			"\t\tS_random_small.insert(small);",
			"\t\tS_increase.insert(i);",
			"\t\tS_decrease.insert(-i);",
			"\t}",
			"",
			"\tauto R_copy(R_random_big);",
			"\tauto S_copy = S_random_big;",
			"\tAVLSet<int> R_assign;",
			"\tR_assign = R_random_big;",
			"\tfor (int i = -MAX; i < MAX; i++) {",
			"\t\tint big = 1000000000 * dist1(engine);",
			"\t\tR_copy.insert(big);",
			"\t\tR_assign.insert(big);",
			"\t\tS_copy.insert(big);",
			"\t}",
			"\tassert(check(R_increase, S_increase));",
			"\tassert(check(R_decrease, S_decrease));",
			"\tassert(check(R_random_big, S_random_big));",
			"\tassert(check(R_random_small, S_random_small));",
			"\tassert(check(R_copy, S_copy));",
			"\tassert(check(R_assign, S_copy));",
			"\tassert(R_increase.is_balanced());",
			"\tassert(R_decrease.is_balanced());",
			"\tassert(R_random_big.is_balanced());",
			"\tassert(R_random_small.is_balanced());",
			"\tassert(R_copy.is_balanced());",
			"\tassert(R_assign.is_balanced());",
			"\treturn;",
			"}",
			"",
			"",
			"void check_erase(const int MAX)",
			"{",
			"\tAVLSet<int> R_random_small;",
			"\tAVLSet<int> R_increase;",
			"\tAVLSet<int> R_decrease;",
			"\tAVLSet<int> R_nothing;",
			"",
			"\tmultiset<int> S_random_small;",
			"\tmultiset<int> S_increase;",
			"\tmultiset<int> S_decrease;",
			"\tmultiset<int> S_nothing;",
			"",
			"\tstd::random_device seed_gen;",
			"\tstd::mt19937 engine(seed_gen());",
			"",
			"\tstd::uniform_real_distribution<> dist1(-1.0, 1.0);",
			"",
			"\tfor (int i = -MAX; i < MAX; i++) {",
			"\t\tint big = 1000000000 * dist1(engine);",
			"\t\tint small = 100 * dist1(engine);",
			"\t\tR_random_small.insert(small);",
			"\t\tR_increase.insert(i);",
			"\t\tR_decrease.insert(i);",
			"\t\tR_nothing.insert(big);",
			"\t\tS_random_small.insert(small);",
			"\t\tS_increase.insert(i);",
			"\t\tS_decrease.insert(i);",
			"\t}",
			"\tfor (int i = 0; i < MAX; i++) {",
			"\t\tR_increase.erase(-i - 1);",
			"\t\tR_decrease.erase(i);",
			"\t\tS_increase.erase(-i - 1);",
			"\t\tS_decrease.erase(i);",
			"\t}",
			"",
			"\tfor (int i = -100; i <= 100; i++) {",
			"\t\tassert(R_random_small.count(i) == (int) S_random_small.count(i));",
			"\t\tassert((int) S_random_small.count(i) == R_random_small.upper_bound(i) - R_random_small.lower_bound(i));",
			"\t}",
			"",
			"\tfor (int i = 0; i < 10; i++) {",
			"\t\tint small = 100 * dist1(engine);",
			"\t\twhile (R_random_small.erase(small) != R_random_small.end());",
			"\t\tS_random_small.erase(small);",
			"\t}",
			"",
			"\tfor (int i = -100; i <= 100; i++) {",
			"\t\tassert(R_random_small.count(i) == (int) S_random_small.count(i));",
			"\t\tassert((int) S_random_small.count(i) == R_random_small.upper_bound(i) - R_random_small.lower_bound(i));",
			"\t}",
			"",
			"",
			"\twhile (R_nothing.erase(*(R_nothing.begin())) != R_nothing.end());",
			"",
			"\tassert(check(R_increase, S_increase));",
			"\tassert(check(R_decrease, S_decrease));",
			"\tassert(check(R_random_small, S_random_small));",
			"\tassert(check(R_nothing, S_nothing));",
			"\tassert(R_increase.is_balanced());",
			"\tassert(R_random_small.is_balanced());",
			"\tassert(R_decrease.is_balanced());",
			"\treturn;",
			"}",
			"",
			"bool check(AVLSet<int>& A, multiset<int>& S)",
			"{",
			"\tauto S_itr = S.begin();",
			"\tauto A_itr = A.begin();",
			"\tfor (;A_itr != A.end(); S_itr++, A_itr++) {",
			"\t\tif (*S_itr != *A_itr) return false;",
			"\t}",
			"\treturn S_itr == S.end();",
			"}"
		]
	},
	"AVLMap": {
		"prefix": "AVLMap",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"using namespace std;",
			"",
			"namespace spihill {",
			"template<class T, class U>",
			"class AVLMapIterator;",
			"",
			"template<class T, class U, class Compare = less<T>>",
			"struct AVLMap {",
			"\tstruct NODE;",
			"\tstruct NODE_LIST;",
			"\tNODE_LIST list_dummy;",
			"\tNODE node_dummy;",
			"\tfriend AVLMapIterator<T, U>;",
			"\tusing iterator = AVLMapIterator<T, U>;",
			"\tAVLMap() {",
			"\t\tnode_dummy.index = &list_dummy;",
			"\t\tlist_dummy.node = &node_dummy;",
			"\t}",
			"\tAVLMap(const AVLMap& R) {",
			"\t\tnode_dummy.index = &list_dummy;",
			"\t\tlist_dummy.node = &node_dummy;",
			"\t\tauto dfs = [&](auto f, NODE* old_node, NODE* new_node) {",
			"\t\t\tif (0) return new_node;",
			"\t\t\tif (old_node->left) {",
			"\t\t\t\tnew_node->left = f(f, old_node->left, new NODE((T&&) *(old_node->left->key), (U&&) *(old_node->left->value), new_node));",
			"\t\t\t}",
			"\t\t\tauto l = new NODE_LIST(&list_dummy, true);",
			"\t\t\tl->node = new_node;",
			"\t\t\tnew_node->index = l;",
			"\t\t\tnew_node->child_size = old_node->child_size;",
			"\t\t\tnew_node->height = old_node->height;",
			"\t\t\tif (old_node->right) {",
			"\t\t\t\tnew_node->right = f(f, old_node->right, new NODE((T&&) *(old_node->right->key), (U&&) *(old_node->right->value), new_node));",
			"\t\t\t}",
			"\t\t\treturn new_node;",
			"\t\t};",
			"\t\tif (R.node_dummy.left) node_dummy.left = dfs(dfs, R.node_dummy.left, new NODE((T&&) *(R.node_dummy.left->key), &node_dummy));",
			"\t}",
			"\tAVLMap& operator=(const AVLMap& R) {",
			"\t\tfor (NODE_LIST* p = list_dummy.fp; p != &list_dummy;) {",
			"\t\t\tp = p->fp;",
			"\t\t\tdelete p->bp;",
			"\t\t}",
			"\t\tnode_dummy.index = &list_dummy;",
			"\t\tlist_dummy.node = &node_dummy;",
			"\t\tauto dfs = [&](auto f, NODE* old_node, NODE* new_node) {",
			"\t\t\tif (0) return new_node;",
			"\t\t\tif (old_node->left) {",
			"\t\t\t\tnew_node->left = f(f, old_node->left, new NODE((T&&) *(old_node->left->key), (U&&) *(old_node->left->value), new_node));",
			"\t\t\t}",
			"\t\t\tauto l = new NODE_LIST(&list_dummy, true);",
			"\t\t\tl->node = new_node;",
			"\t\t\tnew_node->index = l;",
			"\t\t\tnew_node->child_size = old_node->child_size;",
			"\t\t\tnew_node->height = old_node->height;",
			"\t\t\tif (old_node->right) {",
			"\t\t\t\tnew_node->right = f(f, old_node->right, new NODE((T&&) *(old_node->right->key), (U&&) *(old_node->right->value), new_node));",
			"\t\t\t}",
			"\t\t\treturn new_node;",
			"\t\t};",
			"\t\tif (R.node_dummy.left) node_dummy.left = dfs(dfs, R.node_dummy.left, new NODE((T&&) *(R.node_dummy.left->key), &node_dummy));",
			"\t\treturn *this;",
			"\t}",
			"\t~AVLMap() {",
			"\t\tfor (NODE_LIST* p = list_dummy.fp; p != &list_dummy;) {",
			"\t\t\tp = p->fp;",
			"\t\t\tdelete p->bp;",
			"\t\t}",
			"\t}",
			"\tint size() {",
			"\t\tif (node_dummy.left) return node_dummy.left->child_size;",
			"\t\treturn 0;",
			"\t}",
			"\tstruct NODE_LIST {",
			"\t\tNODE_LIST* fp;",
			"\t\tNODE_LIST* bp;",
			"\t\tNODE* node;",
			"\t\tbool dummy = false;",
			"\t\tNODE_LIST() : fp(this), bp(this), node(nullptr), dummy(true) {}",
			"\t\tNODE_LIST(NODE_LIST* p, bool is_left) : node(nullptr) {",
			"\t\t\tNODE_LIST* pre = is_left ? p->bp : p;",
			"\t\t\tNODE_LIST* nex = is_left ? p : p->fp;",
			"\t\t\tbp = pre;",
			"\t\t\tfp = nex;",
			"\t\t\tpre->fp = this;",
			"\t\t\tnex->bp = this;",
			"\t\t}",
			"\t\t~NODE_LIST() {",
			"\t\t\tif (!dummy) delete node;",
			"\t\t}",
			"\t\tint get_position() {",
			"\t\t\tint result = -1;",
			"\t\t\tbool is_left = false;",
			"\t\t\tNODE* n = node;",
			"\t\t\tfor (;; n = n->par) {",
			"\t\t\t\tif (!is_left) result += n->left ? n->left->child_size + 1 : 1;",
			"\t\t\t\tif (n->par) is_left = (n->par->left == n);",
			"\t\t\t\telse break;",
			"\t\t\t}",
			"\t\t\treturn result;",
			"\t\t}",
			"\t};",
			"\tvoid remove_list(NODE_LIST* p) {",
			"\t\tp->bp->fp = p->fp;",
			"\t\tp->fp->bp = p->bp;",
			"\t\tdelete p;",
			"\t}",
			"\tvoid remove_node(NODE* n, bool is_left) {",
			"\t\tif (n->par->left == n) n->par->left = is_left ? n->left : n->right;",
			"\t\telse  n->par->right = is_left ? n->left : n->right;",
			"\t\tif (is_left) n->left->par = n->par;",
			"\t\telse n->right->par = n->par;",
			"\t\tfor (NODE* i = n->par; i != &node_dummy; i = i->par) i->child_size--;",
			"\t\tremove_list(n->index);",
			"\t}",
			"\tvoid remove_node(NODE* n) {",
			"\t\tif (n->par->left == n) n->par->left = nullptr;",
			"\t\telse  n->par->right = nullptr;",
			"\t\tfor (NODE* i = n->par; i != &node_dummy; i = i->par) i->child_size--;",
			"\t\tremove_list(n->index);",
			"\t}",
			"\tstruct NODE {",
			"\t\tT* key;",
			"\t\tU* value;",
			"\t\tNODE_LIST* index;",
			"\t\tNODE* left;",
			"\t\tNODE* right;",
			"\t\tNODE* par;",
			"\t\tint child_size;",
			"\t\tint height;",
			"\t\tNODE() : key(nullptr), value(nullptr), index(nullptr), left(nullptr), right(nullptr), par(nullptr), child_size(0), height(0) {}",
			"\t\tNODE(T&& d, NODE* par_) : index(nullptr), left(nullptr) , right(nullptr), par(par_), child_size(1), height(1) {key = new T(d); value = new U;}",
			"\t\tNODE(T&& d, U&& u, NODE* par_) : index(nullptr), left(nullptr) , right(nullptr), par(par_), child_size(1), height(1) {key = new T(d); value = new U(u);}",
			"\t\t~NODE() {delete key; delete value;}",
			"\t\tvoid RotateR() {",
			"\t\t\tNODE* P = this;",
			"\t\t\tNODE* R = this->par;",
			"\t\t\tNODE* l = this->left;",
			"\t\t\tNODE* B = l->right;",
			"\t\t\tif (R->left == P) R->left = l;",
			"\t\t\telse R->right = l;",
			"\t\t\tl->par = R;",
			"\t\t\tif (B) B->par = P;",
			"\t\t\tP->left = B;",
			"\t\t\tl->right = P;",
			"\t\t\tP->par = l;",
			"\t\t\tint B_size = B ? B->child_size : 0;",
			"\t\t\tP->child_size += B_size - l->child_size;",
			"\t\t\tl->child_size += P->child_size - B_size;",
			"\t\t\tP->update_height();",
			"\t\t\tl->update_height();",
			"\t\t}",
			"\t\tvoid RotateL() {",
			"\t\t\tNODE* P = this;",
			"\t\t\tNODE* R = this->par;",
			"\t\t\tNODE* r = this->right;",
			"\t\t\tNODE* B = r->left;",
			"\t\t\tif (R->left == P) R->left = r;",
			"\t\t\telse R->right = r;",
			"\t\t\tr->par = R;",
			"\t\t\tif (B) B->par = P;",
			"\t\t\tP->right = B;",
			"\t\t\tr->left = P;",
			"\t\t\tP->par = r;",
			"\t\t\tint B_size = B ? B->child_size : 0;",
			"\t\t\tP->child_size += B_size - r->child_size;",
			"\t\t\tr->child_size += P->child_size - B_size;",
			"\t\t\tP->update_height();",
			"\t\t\tr->update_height();",
			"\t\t}",
			"\t\tvoid RotateRL() {",
			"\t\t\tright->RotateR();",
			"\t\t\tRotateL();",
			"\t\t}",
			"\t\tvoid RotateLR() {",
			"\t\t\tleft->RotateL();",
			"\t\t\tRotateR();",
			"\t\t}",
			"\t\tint bias() {",
			"\t\t\tint L = left  ? left->height  : 0;",
			"\t\t\tint R = right ? right->height : 0;",
			"\t\t\treturn L - R;",
			"\t\t}",
			"\t\tvoid update_height() {",
			"\t\t\tint L = left  ? left->height  : 0;",
			"\t\t\tint R = right ? right->height : 0;",
			"\t\t\theight = max(L, R) + 1;",
			"\t\t}",
			"\t};",
			"\tvoid balancing_insert(NODE* parent) {",
			"\t\tfor (;!(parent->index->dummy); parent = parent->par) {",
			"\t\t\tparent->update_height();",
			"\t\t\tif (parent->bias() == 0) return;",
			"\t\t\tif (abs(parent->bias()) != 1) break;",
			"\t\t}",
			"\t\tif (parent != &node_dummy) balancing_rotate(parent);",
			"\t}",
			"\tvoid balancing_erase(NODE* parent) {",
			"\t\tfor (;; parent = parent->par->par) {",
			"\t\t\tfor (;!(parent->index->dummy); parent = parent->par) {",
			"\t\t\t\tparent->update_height();",
			"\t\t\t\tif (abs(parent->bias()) == 1) return;",
			"\t\t\t\tif (parent->bias() != 0) break;",
			"\t\t\t}",
			"\t\t\tif (parent == &node_dummy) return;",
			"\t\t\tbalancing_rotate(parent);",
			"\t\t}",
			"\t}",
			"\tvoid balancing_rotate(NODE* parent) {",
			"\t\tif (parent->bias() == 2) {",
			"\t\t\tif (parent->left->bias() == -1) parent->RotateLR();",
			"\t\t\telse parent->RotateR();",
			"\t\t} else {",
			"\t\t\tif (parent->right->bias() == 1) parent->RotateRL();",
			"\t\t\telse parent->RotateL();",
			"\t\t}",
			"\t}",
			"\titerator erase(T&& k) {",
			"\t\tNODE* now = node_dummy.left;",
			"\t\twhile (now) {",
			"\t\t\tif (Compare()(k, *(now->key))) now = now->left;",
			"\t\t\telse if (Compare()(*(now->key), k)) now = now->right;",
			"\t\t\telse break;",
			"\t\t}",
			"\t\tif (now == nullptr) return iterator(&list_dummy);",
			"\t\tNODE* target;",
			"\t\tif (now->left) target = now->index->bp->node;",
			"\t\telse target = now;",
			"\t\tassert(target->child_size <= 2);",
			"\t\tNODE_LIST* res = now->index->fp;",
			"\t\tswap(now->key, target->key);",
			"\t\tnow = target->par;",
			"\t\tbool is_left = (now->left == target);",
			"\t\tif (target->left) remove_node(target, true);",
			"\t\telse if (target->right) remove_node(target, false);",
			"\t\telse remove_node(target);",
			"\t\tbalancing_erase(now);",
			"\t\treturn iterator(res);",
			"\t}",
			"\titerator erase(const T& k) {",
			"\t\treturn erase((T&&) k);",
			"\t}",
			"\titerator insert(T&& k) {",
			"\t\tNODE* parent = &node_dummy;",
			"\t\tNODE* now = parent->left;",
			"\t\tbool is_left = true;",
			"\t\twhile (now) {",
			"\t\t\tparent = now;",
			"\t\t\tnow->child_size++;",
			"\t\t\tif (is_left = Compare()(k, *(now->key))) now = now->left;",
			"\t\t\telse if (is_left = Compare()(*(now->key), k)) now = now->right;",
			"\t\t\telse return iterator(now->index);",
			"\t\t}",
			"\t\tNODE* child = new NODE((T&&) k, parent);",
			"\t\tif (is_left) parent->left = child;",
			"\t\telse parent->right = child;",
			"\t\tchild->index = new NODE_LIST(parent->index, is_left);",
			"\t\tchild->index->node = child;",
			"\t\tbalancing_insert(parent);",
			"\t\treturn iterator(child->index);",
			"\t}",
			"\titerator insert(const T& k) {",
			"\t\treturn insert((T&&) k);",
			"\t}",
			"\tint count(T&& v) {",
			"\t\tenum STATUS {LEFT, RIGHT, NEUTRAL};",
			"\t\tint sum = 0;",
			"\t\tqueue<pair<STATUS, NODE*>> q;",
			"\t\tq.emplace(NEUTRAL, node_dummy.left);",
			"\t\twhile (!q.empty()) {",
			"\t\t\tpair<STATUS, NODE*> t = q.front();",
			"\t\t\tq.pop();",
			"\t\t\tint status = t.first;",
			"\t\t\tNODE* n = t.second;",
			"\t\t\tif (n == nullptr) continue;",
			"\t\t\tif (status == NEUTRAL) {",
			"\t\t\t\tif (Compare()(v, *(n->key))) q.emplace(NEUTRAL, n->left);",
			"\t\t\t\telse if (Compare()(*(n->key), v)) q.emplace(NEUTRAL, n->right);",
			"\t\t\t\telse {",
			"\t\t\t\t\tsum++;",
			"\t\t\t\t\tq.emplace(LEFT, n->left);",
			"\t\t\t\t\tq.emplace(RIGHT, n->right);",
			"\t\t\t\t}",
			"\t\t\t} else if (status == LEFT) {",
			"\t\t\t\tif (Compare()(*(n->key), v)) q.emplace(LEFT, n->right);",
			"\t\t\t\telse {",
			"\t\t\t\t\tsum += (n->right ? n->right->child_size : 0) + 1;",
			"\t\t\t\t\tq.emplace(LEFT, n->left);",
			"\t\t\t\t}",
			"\t\t\t} else /* if (status == RIGHT) */{",
			"\t\t\t\tif (Compare()(v, *(n->key))) q.emplace(RIGHT, n->left);",
			"\t\t\t\telse {",
			"\t\t\t\t\tsum += (n->left ? n->left->child_size : 0) + 1;",
			"\t\t\t\t\tq.emplace(RIGHT, n->right);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn sum;",
			"\t}",
			"\tint count(const T& v) {",
			"\t\treturn count((T&&) v);",
			"\t}",
			"\tbool is_balanced() {",
			"\t\tauto dfs = [&](auto f, NODE* n, int& height, int& c_size) {",
			"\t\t\tif (0) return false;",
			"\t\t\tif (n == nullptr) {",
			"\t\t\t\theight = 0;",
			"\t\t\t\tc_size = 0;",
			"\t\t\t\treturn true;",
			"\t\t\t}",
			"\t\t\tint L = 0, R = 0;",
			"\t\t\tc_size = 1;",
			"\t\t\tint t;",
			"\t\t\tif (!f(f, n->left, L, t)) return false;",
			"\t\t\tc_size += t;",
			"\t\t\tif (!f(f, n->right, R, t)) return false;",
			"\t\t\tc_size += t;",
			"\t\t\theight = max(L, R) + 1;",
			"\t\t\tif (n->height != height) {",
			"\t\t\t\tcerr << \"hight value is odd.\" << endl;",
			"\t\t\t\treturn false;",
			"\t\t\t}",
			"\t\t\tif (n->bias() < -2 || n->bias() > 2) {",
			"\t\t\t\tcerr << \"bias value is odd.\" << endl;",
			"\t\t\t\tcerr << \"bias : \" << n->bias() << endl;",
			"\t\t\t\treturn false;",
			"\t\t\t}",
			"\t\t\tif (c_size != n->child_size) {",
			"\t\t\t\tcerr << \"child_size is wrong\" << endl;",
			"\t\t\t\tcerr << \"size : \" << n->child_size << endl;",
			"\t\t\t\tcerr << \"real : \" << c_size << endl;",
			"\t\t\t\treturn false;",
			"\t\t\t}",
			"\t\t\theight = std::max(L, R) + 1;",
			"\t\t\treturn true;",
			"\t\t};",
			"\t\tint t, u;",
			"\t\treturn dfs(dfs, node_dummy.left, t, u);",
			"\t}",
			"\titerator begin() {",
			"\t\treturn iterator(list_dummy.fp);",
			"\t}",
			"\titerator end() {",
			"\t\treturn iterator(&list_dummy);",
			"\t}",
			"\titerator lower_bound(T&& v) {",
			"\t\tNODE* now = node_dummy.left;",
			"\t\tNODE* ans = nullptr;",
			"\t\twhile (now != nullptr) {",
			"\t\t\tif (Compare()(*(now->key), v)) {",
			"\t\t\t\tnow = now->right;",
			"\t\t\t}",
			"\t\t\telse {",
			"\t\t\t\tans = now;",
			"\t\t\t\tnow = now->left;",
			"\t\t\t}",
			"\t\t}",
			"\t\tif (ans) return iterator(ans->index);",
			"\t\treturn iterator(&list_dummy);",
			"\t}",
			"\titerator lower_bound(const T& v) {",
			"\t\treturn lower_bound((T&&) v);",
			"\t}",
			"\titerator upper_bound(T&& v) {",
			"\t\tNODE* now = node_dummy.left;",
			"\t\tNODE* ans = nullptr;",
			"\t\twhile (now != nullptr) {",
			"\t\t\tif (Compare()(v, *(now->key))) {",
			"\t\t\t\tans = now;",
			"\t\t\t\tnow = now->left;",
			"\t\t\t}",
			"\t\t\telse {",
			"\t\t\t\tnow = now->right;",
			"\t\t\t}",
			"\t\t}",
			"\t\tif (ans) return iterator(ans->index);",
			"\t\treturn iterator(&list_dummy);",
			"\t}",
			"\titerator upper_bound(const T& v) {",
			"\t\treturn upper_bound((T&&) v);",
			"\t}",
			"//\tconst T& get_kth_element(int k) {",
			"//\t\tif (k < 0 || size() <= k) throw out_of_range(\"Error at AVLMap::get_kth_element(int)\");",
			"//\t\tint pos = 0;",
			"//\t\tNODE* now = node_dummy.left;",
			"//\t\twhile (true) {",
			"//\t\t\tint L = now->left ? now->left->child_size : 0;",
			"//\t\t\tif (Compare()(pos + L, k)) pos += L + 1, now = now->right;",
			"//\t\t\telse if (Compare()(k, L + pos)) now = now->left;",
			"//\t\t\telse break;",
			"//\t\t}",
			"//\t\treturn *(now->key);",
			"//\t}",
			"\tU& operator[](T&& k) {",
			"\t\treturn *(insert((T&&) k).list_ptr->node->value);",
			"\t}",
			"\tU& operator[](const T& k) {",
			"\t\treturn *(insert((T&&) k).list_ptr->node->value);",
			"\t}",
			"};",
			"template<class T, class U>",
			"class AVLMapIterator {",
			"\tfriend AVLMap<T, U>;",
			"\tusing NODE_LIST = typename AVLMap<T, U>::NODE_LIST;",
			"\tNODE_LIST* list_ptr;",
			"\tAVLMapIterator(NODE_LIST* n) : list_ptr(n) {}",
			"public:",
			"\tAVLMapIterator(const AVLMapIterator& R) : list_ptr(R.list_ptr) {}",
			"\tAVLMapIterator& operator++() {",
			"\t\tif (list_ptr->dummy) throw out_of_range(\"Error at AVLMapIterator& operator++()\");",
			"\t\tlist_ptr = list_ptr->fp;",
			"\t\treturn *this;",
			"\t}",
			"\tAVLMapIterator operator++(int unused) {",
			"\t\tif (list_ptr->dummy) throw out_of_range(\"Error at AVLMapIterator operator++(int)\");",
			"\t\tAVLMapIterator result = *this;",
			"\t\tlist_ptr = list_ptr->fp;",
			"\t\treturn result;",
			"\t}",
			"\tAVLMapIterator& operator--() {",
			"\t\tif (list_ptr->bp->dummy) throw out_of_range(\"Error at AVLMapIterator& operator--()\");",
			"\t\tlist_ptr = list_ptr->bp;",
			"\t\treturn *this;",
			"\t}",
			"\tAVLMapIterator operator--(int unused) {",
			"\t\tif (list_ptr->bp->dummy) throw out_of_range(\"Error at AVLMapIterator operator--(int)\");",
			"\t\tAVLMapIterator result = *this;",
			"\t\tlist_ptr = list_ptr->bp;",
			"\t\treturn result;",
			"\t}",
			"\tint operator-(const AVLMapIterator& R) {",
			"\t\treturn list_ptr->get_position() - R.list_ptr->get_position();",
			"\t}",
			"\tconst pair<T, U> operator*() const {",
			"\t\tassert(list_ptr->node->key);",
			"\t\treturn make_pair(*(list_ptr->node->key), *(list_ptr->node->value));",
			"\t}",
			"\tbool operator==(const AVLMapIterator& R) {",
			"\t\treturn this->list_ptr == R.list_ptr;",
			"\t}",
			"\tbool operator!=(const AVLMapIterator& R) {",
			"\t\treturn !(*this == R);",
			"\t}",
			"};",
			"} // namespace",
			"",
			"using namespace spihill;",
			"",
			"/*",
			"",
			"void check_insert(const int);",
			"void check_erase(const int);",
			"bool check(AVLMap<int, int>& R, multiset<int>& S);",
			"*/",
			"int main()",
			"{",
			"\tcout << \"INSERT TEST\" << endl;",
			"//\tcheck_insert(100000);",
			"\tcout << \"TEST PASSED\" << endl;",
			"\tcout << \"ERASE TEST\" << endl;",
			"\tAVLMap<int, int> A;",
			"\tfor (int i = 9; i >= 0; i--) {",
			"\t\tA[i * i] = i;",
			"\t}",
			"\tfor (auto x : A) {",
			"\t\tcout << x.first << \" \" << x.second << endl;",
			"\t}",
			"//\tcheck_erase(100000);",
			"\tcout << \"TEST PASSED\" << endl;",
			"}",
			"",
			"/*",
			"",
			"void check_insert(const int MAX)",
			"{",
			"\tAVLMap<int, int> R_random_big;",
			"\tAVLMap<int, int> R_random_small;",
			"\tAVLMap<int, int> R_increase;",
			"\tAVLMap<int, int> R_decrease;",
			"",
			"\tmultiset<int> S_random_big;",
			"\tmultiset<int> S_random_small;",
			"\tmultiset<int> S_increase;",
			"\tmultiset<int> S_decrease;",
			"",
			"\tstd::random_device seed_gen;",
			"\tstd::mt19937 engine(seed_gen());",
			"",
			"\tstd::uniform_real_distribution<> dist1(-1.0, 1.0);",
			"",
			"\tfor (int i = -MAX; i < MAX; i++) {",
			"\t\tint big = 1000000000 * dist1(engine);",
			"\t\tint small = 100 * dist1(engine);",
			"\t\tR_random_big.insert(big);",
			"\t\tR_random_small.insert(small);",
			"\t\tR_increase.insert(i);",
			"\t\tR_decrease.insert(-i);",
			"\t\tS_random_big.insert(big);",
			"\t\tS_random_small.insert(small);",
			"\t\tS_increase.insert(i);",
			"\t\tS_decrease.insert(-i);",
			"\t}",
			"",
			"\tauto R_copy(R_random_big);",
			"\tauto S_copy = S_random_big;",
			"\tAVLMap<int, int> R_assign;",
			"\tR_assign = R_random_big;",
			"\tfor (int i = -MAX; i < MAX; i++) {",
			"\t\tint big = 1000000000 * dist1(engine);",
			"\t\tR_copy.insert(big);",
			"\t\tR_assign.insert(big);",
			"\t\tS_copy.insert(big);",
			"\t}",
			"\tassert(check(R_increase, S_increase));",
			"\tassert(check(R_decrease, S_decrease));",
			"\tassert(check(R_random_big, S_random_big));",
			"\tassert(check(R_random_small, S_random_small));",
			"\tassert(check(R_copy, S_copy));",
			"\tassert(check(R_assign, S_copy));",
			"\tassert(R_increase.is_balanced());",
			"\tassert(R_decrease.is_balanced());",
			"\tassert(R_random_big.is_balanced());",
			"\tassert(R_random_small.is_balanced());",
			"\tassert(R_copy.is_balanced());",
			"\tassert(R_assign.is_balanced());",
			"\treturn;",
			"}",
			"",
			"",
			"void check_erase(const int MAX)",
			"{",
			"\tAVLMap<int, int> R_random_small;",
			"\tAVLMap<int, int> R_increase;",
			"\tAVLMap<int, int> R_decrease;",
			"\tAVLMap<int, int> R_nothing;",
			"",
			"\tmultiset<int> S_random_small;",
			"\tmultiset<int> S_increase;",
			"\tmultiset<int> S_decrease;",
			"\tmultiset<int> S_nothing;",
			"",
			"\tstd::random_device seed_gen;",
			"\tstd::mt19937 engine(seed_gen());",
			"",
			"\tstd::uniform_real_distribution<> dist1(-1.0, 1.0);",
			"",
			"\tfor (int i = -MAX; i < MAX; i++) {",
			"\t\tint big = 1000000000 * dist1(engine);",
			"\t\tint small = 100 * dist1(engine);",
			"\t\tR_random_small.insert(small);",
			"\t\tR_increase.insert(i);",
			"\t\tR_decrease.insert(i);",
			"\t\tR_nothing.insert(big);",
			"\t\tS_random_small.insert(small);",
			"\t\tS_increase.insert(i);",
			"\t\tS_decrease.insert(i);",
			"\t}",
			"\tfor (int i = 0; i < MAX; i++) {",
			"\t\tR_increase.erase(-i - 1);",
			"\t\tR_decrease.erase(i);",
			"\t\tS_increase.erase(-i - 1);",
			"\t\tS_decrease.erase(i);",
			"\t}",
			"",
			"\tfor (int i = -100; i <= 100; i++) {",
			"\t\tassert(R_random_small.count(i) == (int) S_random_small.count(i));",
			"\t\tassert((int) S_random_small.count(i) == R_random_small.upper_bound(i) - R_random_small.lower_bound(i));",
			"\t}",
			"",
			"\tfor (int i = 0; i < 10; i++) {",
			"\t\tint small = 100 * dist1(engine);",
			"\t\twhile (R_random_small.erase(small) != R_random_small.end());",
			"\t\tS_random_small.erase(small);",
			"\t}",
			"",
			"\tfor (int i = -100; i <= 100; i++) {",
			"\t\tassert(R_random_small.count(i) == (int) S_random_small.count(i));",
			"\t\tassert((int) S_random_small.count(i) == R_random_small.upper_bound(i) - R_random_small.lower_bound(i));",
			"\t}",
			"",
			"",
			"\twhile (R_nothing.erase(*(R_nothing.begin())) != R_nothing.end());",
			"",
			"\tassert(check(R_increase, S_increase));",
			"\tassert(check(R_decrease, S_decrease));",
			"\tassert(check(R_random_small, S_random_small));",
			"\tassert(check(R_nothing, S_nothing));",
			"\tassert(R_increase.is_balanced());",
			"\tassert(R_random_small.is_balanced());",
			"\tassert(R_decrease.is_balanced());",
			"\treturn;",
			"}",
			"",
			"bool check(AVLMap<int, int>& A, multiset<int>& S)",
			"{",
			"\tauto S_itr = S.begin();",
			"\tauto A_itr = A.begin();",
			"\tfor (;A_itr != A.end(); S_itr++, A_itr++) {",
			"\t\tif (*S_itr != *A_itr) return false;",
			"\t}",
			"\treturn S_itr == S.end();",
			"}",
			"*/"
		]
	}
}